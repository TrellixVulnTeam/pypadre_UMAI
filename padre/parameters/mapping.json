{
  "algorithms": [
    {
      "name": "linear regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.base.LinearRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": [
        ]
      }
    },
    {
      "name": "ridge regression",
      "other_names": [
        "Tikhonov regularization",
        "weight decay",
        "Tikhonov–Miller method",
        "Phillips–Twomey method",
        "constrained linear inversion",
        "linear regularization"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.ridge.Ridge"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularisation_strength",
            "kind_of_value": "float, array-like in the shape of the targets",
            "optional": "False",
            "description": "Regularization strength; must be a positive float. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'}",
            "optional": "False",
            "description": "Solver to use in the computational routines: -'auto' chooses the solver automatically based on the type of data. -'svd' uses a Singular Value Decomposition of X to compute the Ridge coefficients. More stable for singular matrices than 'cholesky'. -'cholesky' uses the standard scipy.linalg.solve function to obtain a closed-form solution. -'sparse_cg' uses the conjugate gradient solver as found in scipy.sparse.linalg.cg. As an iterative algorithm, this solver is more appropriate than 'cholesky' for large-scale data. -'lsqr' uses the dedicated regularized least-squares routine scipy.sparse.linalg.lsqr. It is the fastest but may not be available in old scipy versions. It also uses an iterative procedure. -'sag' uses a Stochastic Average Gradient descent, and 'saga' uses its improved, unbiased version named SAGA. Both methods also use an iterative procedure, and are often faster than other solvers when both n_samples and n_features are large. Note that 'sag' and 'saga' fast convergence is only guaranteed on features with approximately the same scale. You can preprocess the data with a scaler from sklearn.preprocessing.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "solver"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": [
        ]
      }
    },
    {
      "name": "lasso",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.Lasso"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1 term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tolerance, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "positive",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "scikit-learn": {
              "default_value": "False",
              "path": "positive"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "{'cyclic', 'random'}",
            "optional": "False",
            "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default.",
            "scikit-learn": {
              "default_value": "'cyclic'",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "multi-task lasso",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.MultiTaskLasso"
      },
      "type": "Regression",
      "hyper_parameters": [
        {
          "name": "l1_l2_multiplier",
          "kind_of_value": "float",
          "optional": "True",
          "description": "Constant that multiplies the L1/L2 term.",
          "scikit-learn": {
            "default_value": "1.0",
            "path": "alpha"
          }
        },
        {
          "name": "fit_intercept",
          "kind_of_value": "boolean",
          "optional": "False",
          "description": "Whether to calculate the intercept for this model.",
          "scikit-learn": {
            "default_value": "True",
            "path": "fit_intercept"
          }
        },
        {
          "name": "normalize",
          "kind_of_value": "boolean",
          "optional": "True",
          "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
          "scikit-learn": {
            "default_value": "False",
            "path": "normalize"
          }
        },
        {
          "name": "tolerance",
          "kind_of_value": "float",
          "optional": "True",
          "description": "The tolerance for the optimization: if the updates are smaller than tol, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
          "scikit-learn": {
            "default_value": "0.0001",
            "path": "tol"
          }
        },
        {
          "name": "reuse_previous",
          "kind_of_value": "boolean",
          "optional": "True",
          "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
          "scikit-learn": {
            "default_value": "False",
            "path": "warm_start"
          }
        },
        {
          "name": "selection",
          "kind_of_value": "{'random', 'cyclic'}",
          "optional": "False",
          "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default.",
          "scikit-learn": {
            "default_value": "'cyclic'",
            "path": "selection"
          }
        }
      ],
      "optimisation_parameters": [
        {
          "name": "max_iterations",
          "kind_of_value": "integer",
          "optional": "True",
          "description": "Maximum number of iterations.",
          "scikit-learn": {
            "default_value": "None",
            "path": "max_iter"
          }
        }
      ],
      "execution_parameters": [
      ]
    },
    {
      "name": "elastic net",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.ElasticNet"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_l2_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1/L2 term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The ElasticNet mixing parameter, with 0 <= l1_ratio <= 1. For l1_ratio = 0 the penalty is an L2 penalty. For l1_ratio = 1 it is an L1 penalty. For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "l1_ratio"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tol, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "positive",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "scikit-learn": {
              "default_value": "False",
              "path": "positive"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "{'random', 'cyclic'}",
            "optional": "False",
            "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default.",
            "scikit-learn": {
              "default_value": "'cyclic'",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "boolean, array-like",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "scikit-learn": {
              "default_value": "False",
              "path": "precompute"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": [
        ]
      }
    },
    {
      "name": "multi-task elastic net",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.MultiTaskElasticNet"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_l2_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1/L2 term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The ElasticNet mixing parameter, with 0 <= l1_ratio <= 1. For l1_ratio = 0 the penalty is an L2 penalty. For l1_ratio = 1 it is an L1 penalty. For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "l1_ratio"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tol, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "{'random', 'cyclic'}",
            "optional": "False",
            "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default.",
            "scikit-learn": {
              "default_value": "'cyclic'",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": [
        ]
      }
    },
    {
      "name": "least angle regression",
      "other_names": [
        "LARS"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.Lars"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "nonzero_coefficients",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Target number of non-zero coefficients.",
            "scikit-learn": {
              "default_value": "500",
              "path": "n_nonzero_coefs"
            }
          },
          {
            "name": "eps",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems.",
            "scikit-learn": {
              "default_value": "2.2204460492503131e-16",
              "path": "eps"
            }
          },
          {
            "name": "positive_coef",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "scikit-learn": {
              "default_value": "False",
              "path": "positive"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "boolean, array-like",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "scikit-learn": {
              "default_value": "False",
              "path": "precompute"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "lasso least angle regression",
      "other_names": [
        "LassoLars"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.LassoLars"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "penalty_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the penalty term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "eps",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems.",
            "scikit-learn": {
              "default_value": "2.2204460492503131e-16",
              "path": "eps"
            }
          },
          {
            "name": "positive_coef",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "scikit-learn": {
              "default_value": "False",
              "path": "positive"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{True, False, 'auto'}",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "precompute"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "orthogonal matching pursuit model",
      "other_names": [
        "OMP"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.OrthogonalMatchingPursuit"
      },
      "type": "Model Fit Aproximator",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "nonzero_coef",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Target number of non-zero coefficients.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_nonzero_coefs"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Maximum norm of the residual.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "True",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{True, False, 'auto'}",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix  and Xy matrix to speed up calculations. Matrices can also be directly passed to the fit method.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "precompute"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "n-target orthogonal matching pursuit",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.orthogonal_mp"
      },
      "type": "Model Fit Aproximator",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "input_data",
            "kind_of_value": "array, shape (n_samples, n_features)",
            "optional": "False",
            "description": "Input data. Columns are assumed to have unit norm.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "input_targets",
            "kind_of_value": "array, shape (n_samples) or (n_samples, n_targets)",
            "optional": "False",
            "description": "Input targets",
            "scikit-learn": {
              "default_value": "",
              "path": "Y"
            }
          },
          {
            "name": "nonzero_coefficients",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Target number of non-zero coefficients.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_nonzero_coefs"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Maximum norm of the residual.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{True, False, 'auto'}",
            "optional": "False",
            "description": "Whether to perform precomputations.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "precompute"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "bayesian ridge regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.BayesianRidge"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "alpha_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the alpha parameter.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "alpha_1"
            }
          },
          {
            "name": "alpha_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the alpha parameter.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "alpha_2"
            }
          },
          {
            "name": "lambda_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the lambda parameter.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "lambda_1"
            }
          },
          {
            "name": "lambda_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the lambda parameter.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "lambda_2"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "300",
              "path": "n_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "automatic relevance determination regression",
      "other_names": [
        "ARD regrssion"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.ARDRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "alpha_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the alpha parameter.",
            "scikit-learn": {
              "default_value": "1e-06",
              "path": "alpha_1"
            }
          },
          {
            "name": "alpha_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the alpha parameter.",
            "scikit-learn": {
              "default_value": "1e-06",
              "path": "alpha_2"
            }
          },
          {
            "name": "lambda_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the lambda parameter.",
            "scikit-learn": {
              "default_value": "1e-06",
              "path": "lambda_1"
            }
          },
          {
            "name": "lambda_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the lambda parameter.",
            "scikit-learn": {
              "default_value": "1e-06",
              "path": "lambda_2"
            }
          },
          {
            "name": "threshold_lambda",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold for removing (pruning) weights with high precision from the computation. ",
            "scikit-learn": {
              "default_value": "10000.0",
              "path": "threshold_lambda"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "300",
              "path": "n_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "logistic regression",
      "other_names": [
        "logit regression",
        "maximum-entropy classification",
        "MaxEnt",
        "log-linear classifier"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.LogisticRegression"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "penalty_norm",
            "kind_of_value": "{l1, l2}",
            "optional": "False",
            "description": "Used to specify the norm used in the penalization.",
            "scikit-learn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Tolerance for stopping criteria.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "inverse_regularisation_strength",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Specifies if a constant (a.k.a. bias or intercept) should be added to the decision function.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict, 'balanced', None}",
            "optional": "False",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{'newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga'}",
            "optional": "False",
            "description": "Solver to use in the computational routines.",
            "scikit-learn": {
              "default_value": "'liblinear'",
              "path": "solver"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of CPU cores used when parallelizing over classes.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "stochastic gradient descent classifier",
      "other_names": [
        "SGD classifier"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.SGDClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss_function",
            "kind_of_value": "{'hinge', 'log', 'modified_huber', 'squared_hinge', 'perceptron', 'squared_loss', 'huber', 'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'hinge'",
              "path": "loss"
            }
          },
          {
            "name": "regularization_term",
            "kind_of_value": "{'none', 'l2', 'l1', 'elasticnet'}",
            "optional": "False",
            "description": "The penalty (aka regularization term) to be used.",
            "scikit-learn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "regualrisation_multiplier",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Constant that multiplies the regularization term.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The Elastic Net mixing parameter.",
            "scikit-learn": {
              "default_value": "0.15",
              "path": "l1_ratio"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{constant, optimal, invscaling}",
            "optional": "True",
            "description": "where t0 is chosen by a heuristic proposed by Leon Bottou.",
            "scikit-learn": {
              "default_value": "optimal",
              "path": "learning_rate"
            }
          },
          {
            "name": "eta0",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The initial learning rate for the 'constant' or 'invscaling' schedules.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "eta0"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The exponent for inverse scaling learning rate.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": " power_t"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{{class_label: weight}, 'balanced',  None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of CPUs to use to do the OVA (One Versus All, for multi-class problems) computation. -1 means 'all CPUs'.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "stochastic gradient descent regressor",
      "other_names": [
        "SGD regressor"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.SGDRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss_function",
            "kind_of_value": "{'squared_loss', 'huber', 'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'squared_loss'",
              "path": "loss"
            }
          },
          {
            "name": "regularization_term",
            "kind_of_value": "{'none', 'l2', 'l1', 'elasticnet'}",
            "optional": "False",
            "description": "The penalty (aka regularization term) to be used.",
            "scikit-learn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "regualrisation_multiplier",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Constant that multiplies the regularization term.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The Elastic Net mixing parameter.",
            "scikit-learn": {
              "default_value": "0.15",
              "path": "l1_ratio"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{'constant', 'optimal', 'invscaling'}",
            "optional": "True",
            "description": "where t0 is chosen by a heuristic proposed by Leon Bottou.",
            "scikit-learn": {
              "default_value": "'invscaling'",
              "path": "learning_rate"
            }
          },
          {
            "name": "eta0",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The initial learning rate for the 'constant' or 'invscaling' schedules.",
            "scikit-learn": {
              "default_value": "0.01",
              "path": "eta0"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The exponent for inverse scaling learning rate.",
            "scikit-learn": {
              "default_value": "0.25",
              "path": " power_t"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "perceptron",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.Perceptron"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularization_term",
            "kind_of_value": "{none, 'l2', 'l1', 'elasticnet'}",
            "optional": "False",
            "description": "The penalty (aka regularization term) to be used.",
            "scikit-learn": {
              "default_value": "None",
              "path": "penalty"
            }
          },
          {
            "name": "regularisation_multiplier",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Constant that multiplies the regularization term.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "eta0",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The initial learning rate for the 'constant' or 'invscaling' schedules.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "eta0"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{{class_label: weight}, 'balanced',  None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          },
          {
            "name": "epochs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of passes over the training data (aka epochs).",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_iter"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "passive aggressive classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.PassiveAggressiveClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regualrisation",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Maximum step size (regularization).",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'hinge', 'squared_hinge'}",
            "optional": "True",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'hinge'",
              "path": "loss"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict,'balanced', None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "epochs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of passes over the training data (aka epochs).",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of of CPUs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "passive aggressive regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.PassiveAggressiveRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regualrisation",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Maximum step size (regularization).",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "True",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'epsilon_insensitive'",
              "path": "loss"
            }
          },
          {
            "name": "update_threshold",
            "kind_of_value": "float",
            "optional": "False",
            "description": "If the difference between the current prediction and the correct label is below this threshold, the model is not updated.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "epsilon"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "epochs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of passes over the training data (aka epochs).",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "random sample consensus regressor",
      "other_names": [
        "RANSAC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.RANSACRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "base_estimator.",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "min_samples",
            "kind_of_value": "[int (>= 1), float ([0, 1])}",
            "optional": "True",
            "description": "Minimum number of samples chosen randomly from original data.",
            "scikit-learn": {
              "default_value": "None",
              "path": "min_samples"
            }
          },
          {
            "name": "residual_threshold",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Maximum residual for a data sample to be classified as an inlier. By default the threshold is chosen as the MAD (median absolute deviation) of the target values y.",
            "scikit-learn": {
              "default_value": "None",
              "path": "residual_threshold"
            }
          },
          {
            "name": "loss",
            "kind_of_value": "{'absolute_loss', 'squared_loss'}",
            "optional": "True",
            "description": "If loss is a callable, then it should be a function that takes two arrays as inputs, the true and predicted value and returns a 1-D array with the i-th value of the array corresponding to the loss on X[i].",
            "scikit-learn": {
              "default_value": "absolute_loss",
              "path": "loss"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "iterations_random_sampling",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations for random sample selection.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_trials"
            }
          },
          {
            "name": "max_skips",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations that can be skipped due to finding zero inliers or invalid data.",
            "scikit-learn": {
              "default_value": "inf",
              "path": "max_skips"
            }
          },
          {
            "name": "stop_n_inliers",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Stop iteration if at least this number of inliers are found.",
            "scikit-learn": {
              "default_value": "inf",
              "path": "stop_n_inliers"
            }
          },
          {
            "name": "stop_score",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Stop iteration if score is greater equal than this threshold.",
            "scikit-learn": {
              "default_value": "inf",
              "path": "stop_score"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "theil-sen estimator",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.TheilSenRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "max_subpopulation",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "",
            "scikit-learn": {
              "default_value": "10000",
              "path": "max_subpopulation"
            }
          },
          {
            "name": "num_subsamples",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of samples to calculate the parameters.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_subsamples"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance when calculating spatial median.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations for the calculation of spatial median.",
            "scikit-learn": {
              "default_value": "300",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of CPUs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "huber regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.HuberRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "number_of_outliers",
            "kind_of_value": "float > 1.0",
            "optional": "False",
            "description": "The parameter controls the number of samples that should be classified as outliers. The smaller the parameter, the more robust it is to outliers.",
            "scikit-learn": {
              "default_value": "1.35",
              "path": "epsilon"
            }
          },
          {
            "name": "regularization_parameter",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Regularization parameter.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "1e-05",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations that scipy.optimize.fmin_l_bfgs_b should run for.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "linear discriminant analysis",
      "other_names": [
        "LDA"
      ],
      "implementation": {
        "scikit-learn": "sklearn.discriminant_analysis.LinearDiscriminantAnalysis"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimation_algorithm",
            "kind_of_value": "{'svd', 'lsqr', 'eigen'}",
            "optional": "True",
            "description": "Possible values: singular value decomposition (svd), least squares solution (lsqr), eigenvalue decomposition (eigen)",
            "scikit-learn": {
              "default_value": "'svd'",
              "path": "solver"
            }
          },
          {
            "name": "shrinkage",
            "kind_of_value": "{None, 'auto', float between 0 and 1}",
            "optional": "True",
            "description": "Shrinkage is a tool to improve estimation of covariance matrices in situations where the number of training samples is small compared to the number of features. Possible values: no shrinkage (None), automatic shrinkage using the Ledoit-Wolf lemma (auto), fixed shrinkage parameter(float between 0 and 1)",
            "scikit-learn": {
              "default_value": "None",
              "path": "shrinkage"
            }
          },
          {
            "name": "n_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of components (< n_classes - 1) for dimensionality reduction.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold used for rank estimation in SVD solver.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "quadratic discriminant analysis",
      "other_names": [
        "QDA"
      ],
      "implementation": {
        "scikit-learn": "sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularisation_parameter",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Regularizes the covariance estimate.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "reg_param"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold used for rank estimation.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "kernel ridge regression",
      "other_names": [
        "KRR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.kernel_ridge.KernelRidge"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularisation_strength",
            "kind_of_value": "float, array-like in the shape of the targets",
            "optional": "False",
            "description": "Regularization strength; must be a positive float. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization. Lambda corresponds to C^-1 in other linear models such as LogisticRegression or LinearSVC.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'cosine', 'gaussian', 'tophat', 'epanechnikov', 'exponential', 'precomputed', callable}",
            "optional": "False",
            "description": "Kernel mapping used internally. A callable should accept two arguments and the keyword arguments passed to this object as kernel_params, and should return a floating point number.",
            "scikit-learn": {
              "default_value": "'linear'",
              "path": "kernel"
            }
          },
          {
            "name": "gamma",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Gamma parameter for the RBF, laplacian, polynomial, exponential chi2 and sigmoid kernels. Interpretation depends on kernels.",
            "scikit-learn": {
              "default_value": "None",
              "path": "gamma"
            }
          },
          {
            "name": "kernel_degree",
            "kind_of_value": "float",
            "optional": "float",
            "description": "Degree of the polynomial kernel.",
            "scikit-learn": {
              "default_value": "3.0",
              "path": "degree"
            }
          },
          {
            "name": "zero_coefficient",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Zero coefficient for polynomial and sigmoid kernels.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "coef0"
            }
          },
          {
            "name": "kernel_parameters",
            "kind_of_value": "mapping of string to any",
            "optional": "True",
            "description": "Additional parameters (keyword arguments) for kernel function passed as callable object.",
            "scikit-learn": {
              "default_value": "None",
              "path": "kernel_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "c-support vector classification.",
      "other_names": [
        "SVC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.SVC"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "{float, 'auto'}",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dictionary with weights for all calsses, 'balanced', None}",
            "optional": "True",
            "description": "Weights the classes. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "nu-support vector classification",
      "other_names": [
        "nuSVC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.NuSVC"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "nu",
            "kind_of_value": "float (0, 1]",
            "optional": "True",
            "description": "An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1].",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "nu"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float or 'auto'",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dictionary with weights for all calsses, 'balanced', None}",
            "optional": "True",
            "description": "Weights the classes. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "linear-support vector classification",
      "other_names": [
        "linear SVC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.LinearSVC"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "penalty_norm",
            "kind_of_value": "{'l1', 'l2'}",
            "optional": "False",
            "description": "Specifies the norm used in the penalization.",
            "scikit-learn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'hinge', 'squared_hinge'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'squared_hinge'",
              "path": "loss"
            }
          },
          {
            "name": "dual",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Select the algorithm to either solve the dual or primal optimization problem.",
            "scikit-learn": {
              "default_value": "True",
              "path": "dual"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criteria.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "multi_class_strategy",
            "kind_of_value": "{'ovr', 'crammer_singer'}",
            "optional": "False",
            "description": "Determines the multi-class strategy if y contains more than two classes.",
            "scikit-learn": {
              "default_value": "'ovr'",
              "path": "multi_class"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dictionary with weights for all calsses, 'balanced', None}",
            "optional": "True",
            "description": "Weights the classes. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations to be run.",
            "scikit-learn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "epsilon-support vector regression",
      "other_names": [
        "SVR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.SVR"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Epsilon in the epsilon-SVR model. It specifies the epsilon-tube within which no penalty is associated in the training loss function with points predicted within a distance epsilon from the actual value.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "epsilon"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float or 'auto'",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "nu-support vector regression",
      "other_names": [
        "nuSVR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.NuSVR"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "nu",
            "kind_of_value": "float (0, 1]",
            "optional": "True",
            "description": "An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1].",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "nu"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float or 'auto'",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "linear-support vector regression",
      "other_names": [
        "linearSVR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.LinearSVR"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'epsilon_insensitive'",
              "path": "loss"
            }
          },
          {
            "name": "epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Epsilon parameter in the epsilon-insensitive loss function. Note that the value of this parameter depends on the scale of the target variable y.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "epsilon"
            }
          },
          {
            "name": "dual",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Select the algorithm to either solve the dual or primal optimization problem.",
            "scikit-learn": {
              "default_value": "True",
              "path": "dual"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations to be run.",
            "scikit-learn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "one-class support vector machine",
      "other_names": [
        "one-calss SVM"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.OneClassSVM"
      },
      "type": "Outlier Detection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "nu",
            "kind_of_value": "float (0, 1]",
            "optional": "True",
            "description": "An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1].",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "nu"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "{float, 'auto'}",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "nearest neighbours",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.NearestNeighbors"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use by default for kneighbors queries.",
            "scikit-learn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "radius",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Range of parameter space to use by default for radius_neighbors queries.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "radius"
            }
          },
          {
            "name": "algorithm",
            "kind_of_value": "{'ball_tree', 'kd_tree', 'brute', 'auto'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "Metric to use for distance computation.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "k-d tree",
      "other_names": [
        "KDTree",
        "k-dimensional tree"
      ],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.KDTree"
      },
      "type": "Search Tree",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "samples_feature",
            "kind_of_value": "array, shape: [n_samples, n_features]",
            "optional": "False",
            "description": "n_samples is the number of points in the data set, and n_features is the dimension of the parameter space.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'p', 'l1', 'chebyshev', 'manhattan', 'minkowski', 'cityblock', 'l2', 'euclidean', 'infinity'}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "leaf_size",
            "kind_of_value": "positive integer",
            "optional": "False",
            "description": "Number of points at which to switch to brute-force. Changing leaf_size will not affect the results of a query, but can significantly impact the speed of a query and the memory required to store the constructed tree.",
            "scikit-learn": {
              "default_value": "40",
              "path": "leaf_size"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "ball tree",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.BallTree"
      },
      "type": "Search Tree",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "samples_feature",
            "kind_of_value": "array, shape: [n_samples, n_features]",
            "optional": "False",
            "description": "n_samples is the number of points in the data set, and n_features is the dimension of the parameter space.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'seuclidean', 'hamming', 'dice', 'jaccard', 'matching', 'russellrao',  'euclidean', 'kulsinski', 'wminkowski', 'chebyshev', 'mahalanobis', 'sokalmichener', 'rogerstanimoto', 'infinity', 'p', 'canberra',  'haversine', 'sokalsneath', 'l1', 'minkowski', 'pyfunc', 'l2', 'cityblock', 'braycurtis', 'manhattan'}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "leaf_size",
            "kind_of_value": "positive integer",
            "optional": "False",
            "description": "Number of points at which to switch to brute-force. Changing leaf_size will not affect the results of a query, but can significantly impact the speed of a query and the memory required to store the constructed tree.",
            "scikit-learn": {
              "default_value": "40",
              "path": "leaf_size"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "radius neighbors classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.RadiusNeighborsClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "radius",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Range of parameter space to use.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "radius"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{'uniform', 'distance', callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "scikit-learn": {
              "default_value": "'uniform'",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "outlier_label",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Label, which is given for outlier samples (samples with no neighbors on given radius). If set to None, ValueError is raised, when outlier is detected.",
            "scikit-learn": {
              "default_value": "None",
              "path": "outlier_label"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "k-nn classifier",
      "other_names": [
        " k-nearest neighbors calssifier"
      ],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.KNeighborsClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_neighbors",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use.",
            "scikit-learn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{'uniform', 'distance', callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "scikit-learn": {
              "default_value": "'uniform'",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "k-nn regressor",
      "other_names": [
        " k-nearest neighbors regressor"
      ],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.KNeighborsRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_neighbors",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use.",
            "scikit-learn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{'uniform', 'distance', callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "scikit-learn": {
              "default_value": "'uniform'",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "radius neighbors regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.RadiusNeighborsRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "radius",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Range of parameter space to use.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "radius"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{'uniform', 'distance', callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "scikit-learn": {
              "default_value": "'uniform'",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "nearest centroid classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.NearestCentroid"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'}",
            "optional": "False",
            "description": "The metric to use when calculating distance between instances in a feature array.",
            "scikit-learn": {
              "default_value": "'euclidean''",
              "path": "metric"
            }
          },
          {
            "name": "shrink_threshold",
            "kind_of_value": "float or None",
            "optional": "True",
            "description": "Threshold for shrinking centroids to remove features.",
            "scikit-learn": {
              "default_value": "None",
              "path": "shrink_threshold"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "gaussian process regression",
      "other_names": [
        "GPR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.gaussian_process.GaussianProcessRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "kernel",
            "kind_of_value": "kernel object",
            "optional": "False",
            "description": "The kernel specifying the covariance function of the GP.",
            "scikit-learn": {
              "default_value": "None",
              "path": "kernel"
            }
          },
          {
            "name": "kernel_optimizer",
            "kind_of_value": "{'fmin_l_bfgs_b', externally defined optimizer passed as a callable }",
            "optional": "True",
            "description": "Optimizer to optimize the kernel parameters.",
            "scikit-learn": {
              "default_value": "'fmin_l_bfgs_b'",
              "path": "optimizer"
            }
          },
          {
            "name": "n_restarts_optimizer",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of restarts of the optimizer for finding the kernel's parameters which maximize the log-marginal likelihood. The first run of the optimizer is performed from the kernel's initial parameters, the remaining ones (if any) from thetas sampled log-uniform randomly from the space of allowed theta-values.",
            "scikit-learn": {
              "default_value": "0",
              "path": "n_restarts_optimizer"
            }
          },
          {
            "name": "normalize_y",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether the target values y are normalized, i.e., the mean of the observed target values become zero. This parameter should be set to True if the target values' mean is expected to differ considerable from zero. When enabled, the normalization effectively modifies the GP's prior based on the data, which contradicts the likelihood principle.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize_y"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "gaussian process classification",
      "other_names": [
        "GPC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.gaussian_process.GaussianProcessClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "kernel",
            "kind_of_value": "kernel object",
            "optional": "False",
            "description": "The kernel specifying the covariance function of the GP.",
            "scikit-learn": {
              "default_value": "None",
              "path": "kernel"
            }
          },
          {
            "name": "kernel_optimizer",
            "kind_of_value": "{'fmin_l_bfgs_b', externally defined optimizer passed as a callable }",
            "optional": "True",
            "description": "Optimizer to optimize the kernel parameters.",
            "scikit-learn": {
              "default_value": "'fmin_l_bfgs_b'",
              "path": "optimizer"
            }
          },
          {
            "name": "n_restarts_optimizer",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of restarts of the optimizer for finding the kernel's parameters which maximize the log-marginal likelihood. The first run of the optimizer is performed from the kernel's initial parameters, the remaining ones (if any) from thetas sampled log-uniform randomly from the space of allowed theta-values.",
            "scikit-learn": {
              "default_value": "0",
              "path": "n_restarts_optimizer"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, the solution of the last Newton iteration on the Laplace approximation of the posterior mode is used as initialization for the next call, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "multi_class",
            "kind_of_value": "{'one_vs_rest', 'one_vs_one'}",
            "optional": "False",
            "description": "Specifies how multi-class classification problems are handled.",
            "scikit-learn": {
              "default_value": "'one_vs_rest'",
              "path": "multi_class"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "partial least squares regression",
      "other_names": [
        "PLS Regession"
      ],
      "implementation": {
        "scikit-learn": "sklearn.cross_decomposition.PLSRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of components to keep.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "scale",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to scale the data.",
            "scikit-learn": {
              "default_value": "True",
              "path": "scale"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "positive float",
            "optional": "False",
            "description": "Tolerance used in the iterative algorithm.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations of the NIPALS inner loop.",
            "scikit-learn": {
              "default_value": "500",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "2 blocks canonical partial least squares",
      "other_names": [
        "PLS Canonical"
      ],
      "implementation": {
        "scikit-learn": "sklearn.cross_decomposition.PLSCanonical"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of components to keep.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "scale",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to scale the data.",
            "scikit-learn": {
              "default_value": "True",
              "path": "scale"
            }
          },
          {
            "name": "weight_algorithm",
            "kind_of_value": "{'nipals', 'svd'}",
            "optional": "False",
            "description": "The algorithm used to estimate the weights.",
            "scikit-learn": {
              "default_value": "'nipals'",
              "path": "algorithm"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "positive float",
            "optional": "False",
            "description": "Tolerance used in the iterative algorithm.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations of the NIPALS inner loop.",
            "scikit-learn": {
              "default_value": "500",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "partial least squares singular value decomposition",
      "other_names": [
        "PLSSVD"
      ],
      "implementation": {
        "scikit-learn": "sklearn.cross_decomposition.PLSSVD"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of components to keep.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "scale",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to scale the data.",
            "scikit-learn": {
              "default_value": "True",
              "path": "scale"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "canonical correlation analysis",
      "other_names": [
        "CCA"
      ],
      "implementation": {
        "scikit-learn": "sklearn.cross_decomposition.CCA"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of components to keep.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "scale",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to scale the data.",
            "scikit-learn": {
              "default_value": "True",
              "path": "scale"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "positive float",
            "optional": "False",
            "description": "Tolerance used in the iterative algorithm.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations of the NIPALS inner loop.",
            "scikit-learn": {
              "default_value": "500",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "gaussian naive bayes",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.naive_bayes.GaussianNB"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "class_priors",
            "kind_of_value": "array-like, shape (n_classes)",
            "optional": "False",
            "description": "Prior probabilities of the classes. If specified the priors are not adjusted according to the data.",
            "scikit-learn": {
              "default_value": "None",
              "path": "priors"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "multinomial naive bayes classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.naive_bayes.MultinomialNB"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "smoothing parameter",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Additive (Laplace/Lidstone) smoothing parameter.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "learn_prior_probabilities",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to learn class prior probabilities or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_prior"
            }
          },
          {
            "name": "class_priors",
            "kind_of_value": "array-like, shape (n_classes)",
            "optional": "False",
            "description": "Prior probabilities of the classes. If specified the priors are not adjusted according to the data.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_prior"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "bernoulli naive bayes classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.naive_bayes.BernoulliNB"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "smoothing parameter",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Additive (Laplace/Lidstone) smoothing parameter.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "binarizeing_threshold",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold for binarizing (mapping to booleans) of sample features.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "binarize"
            }
          },
          {
            "name": "learn_prior_probabilities",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to learn class prior probabilities or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_prior"
            }
          },
          {
            "name": "class_priors",
            "kind_of_value": "array-like, shape (n_classes)",
            "optional": "False",
            "description": "Prior probabilities of the classes. If specified the priors are not adjusted according to the data.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_prior"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "",
            "kind_of_value": "",
            "optional": "",
            "description": "",
            "scikit-learn": {
              "default_value": "",
              "path": ""
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "decision tree classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.tree.DecisionTreeClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "split_quality",
            "kind_of_value": "{'gini', 'entropy'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'gini'",
              "path": "criterion"
            }
          },
          {
            "name": "splitting_strategy",
            "kind_of_value": "{'best', 'random'}",
            "optional": "True",
            "description": "The strategy used to choose the split at each node.",
            "scikit-learn": {
              "default_value": "'best'",
              "path": "splitter"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_features"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict, list of dicts, 'balanced', None}",
            "optional": "False",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "decision tree regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.tree.DecisionTreeRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'friedman_mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'mse'",
              "path": "criterion"
            }
          },
          {
            "name": "splitting_strategy",
            "kind_of_value": "{'best', 'random'}",
            "optional": "True",
            "description": "The strategy used to choose the split at each node.",
            "scikit-learn": {
              "default_value": "'best'",
              "path": "splitter"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_features"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "presort",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to presort the data to speed up the finding of best splits in fitting.",
            "scikit-learn": {
              "default_value": "False",
              "path": "presort"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "extra-trees regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.ExtraTreesRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'mse'",
              "path": "criterion"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "max_features"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "scikit-learn": {
              "default_value": "False",
              "path": "bootstrap"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the R^2 on unseen data.",
            "scikit-learn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "extra-trees classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.ExtraTreesClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'gini', 'entropy'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'gini'",
              "path": "criterion"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "max_features"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "scikit-learn": {
              "default_value": "False",
              "path": "bootstrap"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the generalization accuracy.",
            "scikit-learn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict, 'balanced', 'balanced_subsample', None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "random forest regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.RandomForestRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'mse'",
              "path": "criterion"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "max_features"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "scikit-learn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use out-of-bag samples to estimate the R^2 on unseen data.",
            "scikit-learn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "random forest classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.RandomForestClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'gini', 'entropy'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'gini'",
              "path": "criterion"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "max_features"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "scikit-learn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the generalization accuracy.",
            "scikit-learn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict, 'balanced', None}",
            "optional": "False",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "bagging classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.BaggingClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "The base estimator to fit on random subsets of the dataset.",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_samples",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of samples to draw from X to train each base estimator.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "max_samples"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of features to draw from X to train each base estimator.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "max_features"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether samples are drawn with replacement.",
            "scikit-learn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "bootstrap_features",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether features are drawn with replacement.",
            "scikit-learn": {
              "default_value": "False",
              "path": "bootstrap_features"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the generalization error.",
            "scikit-learn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new ensemble.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "bagging regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.BaggingRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "The base estimator to fit on random subsets of the dataset.",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_samples",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of samples to draw from X to train each base estimator.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "max_samples"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of features to draw from X to train each base estimator.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "max_features"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether samples are drawn with replacement.",
            "scikit-learn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "bootstrap_features",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether features are drawn with replacement.",
            "scikit-learn": {
              "default_value": "False",
              "path": "bootstrap_features"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the generalization error.",
            "scikit-learn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new ensemble.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "vating classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.VotingClassifier"
      },
      "type": "Classifcation",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimators",
            "kind_of_value": "string, estimator tuple{('lr', clf1), ('rf', clf2), ('gnb', clf3), ('dt', clf1), ('knn', clf2), ('svc', clf3)}",
            "optional": "False",
            "description": "Used estimators.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimators"
            }
          },
          {
            "name": "voting",
            "kind_of_value": "{'hard', 'soft'}",
            "optional": "False",
            "description": "If 'hard', uses predicted class labels for majority rule voting. Else if 'soft', predicts the class label based on the argmax of the sums of the predicted probabilities, which is recommended for an ensemble of well-calibrated classifiers.",
            "scikit-learn": {
              "default_value": "'hard'",
              "path": "voting"
            }
          },
          {
            "name": "weights",
            "kind_of_value": "array-like, shape = [n_classifiers] integer, float, None",
            "optional": "True",
            "description": "Sequence of weights (float or int) to weight the occurrences of predicted class labels (hard voting) or class probabilities before averaging (soft voting). Uses uniform weights if None.",
            "scikit-learn": {
              "default_value": "None",
              "path": "weights"
            }
          },
          {
            "name": "flatten_transform",
            "kind_of_value": "boolean, None",
            "optional": "True",
            "description": "Affects shape of transform output only when voting='soft'.",
            "scikit-learn": {
              "default_value": "None",
              "path": "flatten_transform"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "gradient boosting for regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.GradientBoostingRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss",
            "kind_of_value": "{'ls', 'lad', 'huber', 'quantile'}",
            "optional": "True",
            "description": "Loss function to be optimized.",
            "scikit-learn": {
              "default_value": "'ls'",
              "path": "loss"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "learning rate shrinks the contribution of each tree by learning_rate.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "learning_rate"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of boosting stages to perform. Gradient boosting is fairly robust to over-fitting so a large number usually results in better performance.",
            "scikit-learn": {
              "default_value": "100",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum depth of the individual regression estimators. The maximum depth limits the number of nodes in the tree. Tune this parameter for best performance; the best value depends on the interaction of the input variables.",
            "scikit-learn": {
              "default_value": "3",
              "path": "max_depth"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'friedman_mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'friedman_mse'",
              "path": "criterion"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "frac_subsample",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The fraction of samples to be used for fitting the individual base learners.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "subsample"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_features"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "integer, None",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "alpha_quantile",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The alpha-quantile of the huber loss function and the quantile loss function. ",
            "scikit-learn": {
              "default_value": "0.9",
              "path": "alpha"
            }
          },
          {
            "name": "init_estimator",
            "kind_of_value": "BaseEstimator, None",
            "optional": "True",
            "description": "An estimator object that is used to compute the initial predictions.",
            "scikit-learn": {
              "default_value": "None",
              "path": "init"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "presort",
            "kind_of_value": "{boolean, 'auto'}",
            "optional": "True",
            "description": "Whether to presort the data to speed up the finding of best splits in fitting.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "presort"
            }
          }
        ],
        "optimisation_parameters": [
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "gradient boosting for classification",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.GradientBoostingClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss",
            "kind_of_value": "{'deviance', 'exponential'}",
            "optional": "True",
            "description": "Loss function to be optimized.",
            "scikit-learn": {
              "default_value": "'deviance'",
              "path": "loss"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "learning rate shrinks the contribution of each tree by learning_rate.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "learning_rate"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of boosting stages to perform. Gradient boosting is fairly robust to over-fitting so a large number usually results in better performance.",
            "scikit-learn": {
              "default_value": "100",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum depth of the individual regression estimators. The maximum depth limits the number of nodes in the tree. Tune this parameter for best performance; the best value depends on the interaction of the input variables.",
            "scikit-learn": {
              "default_value": "3",
              "path": "max_depth"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'friedman_mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'friedman_mse'",
              "path": "criterion"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "frac_subsample",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The fraction of samples to be used for fitting the individual base learners.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "subsample"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_features"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "integer, None",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "init_estimator",
            "kind_of_value": "BaseEstimator, None",
            "optional": "True",
            "description": "An estimator object that is used to compute the initial predictions.",
            "scikit-learn": {
              "default_value": "None",
              "path": "init"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "presort",
            "kind_of_value": "{boolean, 'auto'}",
            "optional": "True",
            "description": "Whether to presort the data to speed up the finding of best splits in fitting.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "presort"
            }
          }
        ],
        "optimisation_parameters": [
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "AdaBoost regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.AdaBoostRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "base_estimator.",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of estimators at which boosting is terminated. In case of perfect fit, the learning procedure is stopped early.",
            "scikit-learn": {
              "default_value": "50",
              "path": "n_estimators"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Learning rate shrinks the contribution of each regressor by learning_rate.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "learning_rate"
            }
          },
          {
            "name": "loss",
            "kind_of_value": "{'linear', 'square', 'exponential'}",
            "optional": "True",
            "description": "Loss function to be optimized.",
            "scikit-learn": {
              "default_value": "'linear'",
              "path": "loss"
            }
          }
        ],
        "optimisation_parameters": [
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "AdaBoost classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.AdaBoostClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "base_estimator.",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of estimators at which boosting is terminated. In case of perfect fit, the learning procedure is stopped early.",
            "scikit-learn": {
              "default_value": "50",
              "path": "n_estimators"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Learning rate shrinks the contribution of each regressor by learning_rate.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "learning_rate"
            }
          },
          {
            "name": "boosting_algorithm",
            "kind_of_value": " {'SAMME', 'SAMME.R'}",
            "optional": "True",
            "description": "If ‘SAMME.R’ then use the SAMME.R real boosting algorithm. base_estimator must support calculation of class probabilities. If ‘SAMME’ then use the SAMME discrete boosting algorithm. The SAMME.R algorithm typically converges faster than SAMME, achieving a lower test error with fewer boosting iterations.",
            "scikit-learn": {
              "default_value": "'SAMME.R'",
              "path": "algorithm"
            }
          }
        ],
        "optimisation_parameters": [
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "random trees ensemble",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.RandomTreesEmbedding"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "scikit-learn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "sparse_output",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether or not to return a sparse CSR matrix, as default behavior, or to return a dense array compatible with dense pipeline operators.",
            "scikit-learn": {
              "default_value": "True",
              "path": "sparse_output"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "classifier chain",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.multioutput.ClassifierChain"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "estimator",
            "optional": "False",
            "description": "The base estimator from which the classifier chain is built.",
            "scikit-learn": {
              "default_value": "",
              "path": "base_estimator"
            }
          },
          {
            "name": "prediction_order",
            "kind_of_value": "{array-like, shape=[n_outputs], 'random', None}",
            "optional": "True",
            "description": "Order in which the chain makes predictions about the columns in the label matrix Y.",
            "scikit-learn": {
              "default_value": "None",
              "path": "order"
            }
          },
          {
            "name": "cross-validation",
            "kind_of_value": "{integer, object (cross-validation generator),  iterable yielding train, test splits, None",
            "optional": "True",
            "description": "Determines whether to use cross validated predictions or true labels for the results of previous estimators in the chain.",
            "scikit-learn": {
              "default_value": "None",
              "path": "cv"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "multi target regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.multioutput.MultiOutputRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "An estimator object implementing fit and predict.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "multi label binarizer",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.preprocessing.MultiLabelBinarizer"
      },
      "type": "Transformation",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "classes",
            "kind_of_value": "{array-like of shape [n_classes], None}",
            "optional": "True",
            "description": "Indicates an ordering for the class labels",
            "scikit-learn": {
              "default_value": "None",
              "path": "classes"
            }
          },
          {
            "name": "sparse_output",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Set to true if output binary array is desired in CSR sparse format",
            "scikit-learn": {
              "default_value": "Flase",
              "path": "sparse_output"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "output code classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.multiclass.OutputCodeClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "An estimator object implementing fit and either predict or decision.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          },
          {
            "name": "code_size",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Percentage of the number of classes to be used to create the code book. A number between 0 and 1 will require fewer classifiers than one-vs-the-rest. A number greater than 1 will require more classifiers than one-vs-the-rest.",
            "scikit-learn": {
              "default_value": "1.5",
              "path": "code_size"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "one vs one classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.multiclass.OneVsOneClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "An estimator object implementing fit and either predict or decision.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          }
        ],
        "optimisation_parameters": [
         {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "one vs rest classifier",
      "other_names": ["one vs all classifier"],
      "implementation": {
        "scikit-learn": "sklearn.multiclass.OneVsRestClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "An estimator object implementing fit and either predict or decision.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          }
        ],
        "optimisation_parameters": [
         {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "select from model",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.SelectFromModel"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "The base estimator from which the transformer is built.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          },
          {
            "name": "threshold",
            "kind_of_value": "{'median', 'mean', float, None}",
            "optional": "True",
            "description": "The threshold value to use for feature selection.",
            "scikit-learn": {
              "default_value": "None",
              "path": "threshold"
            }
          },
          {
            "name": "prefit_model",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether a prefit model is expected to be passed into the constructor directly or not.",
            "scikit-learn": {
              "default_value": "False",
              "path": "prefit"
            }
          },
          {
            "name": "norm_order",
            "kind_of_value": "non-zero integer",
            "optional": "False",
            "description": "Order of the norm used to filter the vectors of coefficients below threshold in the case where the coef_ attribute of the estimator is of dimension 2.",
            "scikit-learn": {
              "default_value": "1",
              "path": "norm_order"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "recursive feature elimination with cross-validation",
      "other_names": ["RFECV"],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.RFECV"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "The base estimator from which the transformer is built.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          },
          {
            "name": "step",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "If greater than or equal to 1, then step corresponds to the (integer) number of features to remove at each iteration. If within (0.0, 1.0), then step corresponds to the percentage (rounded down) of features to remove at each iteration.",
            "scikit-learn": {
              "default_value": "1",
              "path": "step"
            }
          },
          {
            "name": "cross-validation",
            "kind_of_value": "{integer, object (cross-validation generator),  iterable yielding train, test splits, None",
            "optional": "True",
            "description": "Determines whether to use cross validated predictions or true labels for the results of previous estimators in the chain.",
            "scikit-learn": {
              "default_value": "None",
              "path": "cv"
            }
          },
          {
            "name": "scoring",
            "kind_of_value": "{callable, None, 'accuracy', 'average_precision', 'f1', 'f1_micro', 'f1_macro', 'f1_weighted', 'f1_samples', 'neg_log_loss', 'precision', 'recall', 'roc_auc', 'adjusted_mutual_info_score', 'adjusted_rand_score', 'completeness_score', 'fowlkes_mallows_score', 'homogeneity_score', 'mutual_info_score', 'normalized_mutual_info_score', 'v_measure_score', 'explained_variance', 'neg_mean_absolute_error', '‘neg_mean_squared_error', 'neg_mean_squared_log_error', 'neg_median_absolute_error', 'r2'}",
            "optional": "True",
            "description": "Scoring parameter that is applied to the evaluated estimator.",
            "scikit-learn": {
              "default_value": "None",
              "path": "scoring"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Controls verbosity of output.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "recursive feature elimination",
      "other_names": ["RFE"],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.RFE"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "The base estimator from which the transformer is built.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          },
          {
            "name": "n_features_to_select",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "The number of features to select. If None, half of the features are selected.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_features_to_select"
            }
          },
          {
            "name": "step",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "If greater than or equal to 1, then step corresponds to the (integer) number of features to remove at each iteration. If within (0.0, 1.0), then step corresponds to the percentage (rounded down) of features to remove at each iteration.",
            "scikit-learn": {
              "default_value": "1",
              "path": "step"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Controls verbosity of output.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "mutual information classification",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.mutual_info_classif"
      },
      "type": "Scoring Function",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "feature_matrix",
            "kind_of_value": " array_like or sparse matrix, shape (n_samples, n_features)",
            "optional": "False",
            "description": "Feature matrix.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "target_vector",
            "kind_of_value": "array_like, shape (n_samples)",
            "optional": "False",
            "description": "Target vector.",
            "scikit-learn": {
              "default_value": "",
              "path": "y"
            }
          },
          {
            "name": "discrete_features",
            "kind_of_value": "{'auto', bool, array_like}",
            "optional": "False",
            "description": "If bool, then determines whether to consider all features discrete or continuous. If array, then it should be either a boolean mask with shape (n_features,) or array with indices of discrete features. If ‘auto’, it is assigned to False for dense X and to True for sparse X.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "discrete_features"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use for MI estimation for continuous variables.",
            "scikit-learn": {
              "default_value": "3",
              "path": "n_neighbors"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "mutual information regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.mutual_info_regression"
      },
      "type": "Scoring Function",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "feature_matrix",
            "kind_of_value": " array_like or sparse matrix, shape (n_samples, n_features)",
            "optional": "False",
            "description": "Feature matrix.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "target_vector",
            "kind_of_value": "array_like, shape (n_samples)",
            "optional": "False",
            "description": "Target vector.",
            "scikit-learn": {
              "default_value": "",
              "path": "y"
            }
          },
          {
            "name": "discrete_features",
            "kind_of_value": "{'auto', bool, array_like}",
            "optional": "False",
            "description": "If bool, then determines whether to consider all features discrete or continuous. If array, then it should be either a boolean mask with shape (n_features,) or array with indices of discrete features. If ‘auto’, it is assigned to False for dense X and to True for sparse X.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "discrete_features"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use for MI estimation for continuous variables.",
            "scikit-learn": {
              "default_value": "3",
              "path": "n_neighbors"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "f classification",
      "other_names": ["analysis of variance f-value"],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.f_classif"
      },
      "type": "Scoring Function",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regressor_set",
            "kind_of_value": "{array-like, sparse matrix} shape = [n_samples, n_features]",
            "optional": "False",
            "description": "The set of regressors that will be tested sequentially.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "data_matrix",
            "kind_of_value": "array of shape(n_samples)",
            "optional": "False",
            "description": "The data matrix.",
            "scikit-learn": {
              "default_value": "",
              "path": "y"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "f regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.f_regression"
      },
      "type": "Scoring Function",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regressor_set",
            "kind_of_value": "{array-like, sparse matrix} shape = [n_samples, n_features]",
            "optional": "False",
            "description": "The set of regressors that will be tested sequentially.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "data_matrix",
            "kind_of_value": "array of shape(n_samples)",
            "optional": "False",
            "description": "The data matrix.",
            "scikit-learn": {
              "default_value": "",
              "path": "y"
            }
          },
          {
            "name": "center",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "If true, regressor_set and data_matrix will be centered.",
            "scikit-learn": {
              "default_value": "",
              "path": "center"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "chi2",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.chi2"
      },
      "type": "Scoring Function",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "sample_vectors",
            "kind_of_value": "{array-like, sparse matrix}, shape = (n_samples, n_features_in)",
            "optional": "False",
            "description": "Sample vectors.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "target_vector",
            "kind_of_value": "array-like, shape = (n_samples)",
            "optional": "False",
            "description": "Target vector (class labels).",
            "scikit-learn": {
              "default_value": "",
              "path": "y"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "univariate feature selector",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.GenericUnivariateSelect"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "scikit-learn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "mode",
            "kind_of_value": " {'percentile', 'k_best', 'fpr', 'fdr', 'fwe'}",
            "optional": "False",
            "description": "Feature selection mode.",
            "scikit-learn": {
              "default_value": "'percentile'",
              "path": "mode"
            }
          },
          {
            "name": "mode_parameter",
            "kind_of_value": "{float, integer}",
            "optional": "False",
            "description": "Parameter of the corresponding mode.",
            "scikit-learn": {
              "default_value": "0,00001",
              "path": "param"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select familiy-wise error rate",
      "other_names": ["select Fwe"],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.SelectFwe"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "scikit-learn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "max_uncorrected_p-value",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The highest uncorrected p-value for features to keep.",
            "scikit-learn": {
              "default_value": "0.05",
              "path": "alpha"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select estimated false discovery rate",
      "other_names": ["select Fdr"],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.SelectFdr"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "scikit-learn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "max_uncorrected_p-value",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The highest uncorrected p-value for features to keep.",
            "scikit-learn": {
              "default_value": "0.05",
              "path": "alpha"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select below false positive rate",
      "other_names": ["select Fpr"],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.SelectFpr"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "scikit-learn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "max_uncorrected_p-value",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The highest uncorrected p-value for features to keep.",
            "scikit-learn": {
              "default_value": "0.05",
              "path": "alpha"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select percentile",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.SelectPercentile"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "scikit-learn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "percentile",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Percent of features to keep.",
            "scikit-learn": {
              "default_value": "10",
              "path": "percentile"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select k best",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.SelectKBest"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "scikit-learn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "k",
            "kind_of_value": "{integer, 'all'}",
            "optional": "True",
            "description": "Number of top features to select.",
            "scikit-learn": {
              "default_value": "10",
              "path": "k"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "variance threshold",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.VarianceThreshold"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "threshold",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Features with a training-set variance lower than this threshold will be removed.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "threshold"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "label probagation",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.semi_supervised.LabelPropagation"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "kernel",
            "kind_of_value": "{'knn', 'rbf', a callable taking two inputs in shape (n_samples, n_features) and returns weight matrix in shape [n_samples, n_samples]}",
            "optional": "False",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "rbf_parameter",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Parameter for rbf kernel",
            "scikit-learn": {
              "default_value": "20",
              "path": "gamma"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer > 0",
            "optional": "True",
            "description": "Number of neighbors to use by for knn kernel.",
            "scikit-learn": {
              "default_value": "7",
              "path": "n_neighbors"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Convergence tolerance: threshold to consider the system at steady state",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "label spreading",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.semi_supervised.LabelSpreading"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "kernel",
            "kind_of_value": "{'knn', 'rbf', a callable taking two inputs in shape (n_samples, n_features) and returns weight matrix in shape [n_samples, n_samples]}",
            "optional": "False",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "rbf_parameter",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Parameter for rbf kernel",
            "scikit-learn": {
              "default_value": "20",
              "path": "gamma"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer > 0",
            "optional": "True",
            "description": "Number of neighbors to use by for knn kernel.",
            "scikit-learn": {
              "default_value": "7",
              "path": "n_neighbors"
            }
          },
          {
            "name": "calmping_factor",
            "kind_of_value": "float in [0,1]",
            "optional": "False",
            "description": "Clamping factor. A value in [0, 1] that specifies the relative amount that an instance should adopt the information from its neighbors as opposed to its initial label. 0 means  keeping the initial label information; 1 means replacing all initial information.",
            "scikit-learn": {
              "default_value": "0.2",
              "path": "alpha"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Convergence tolerance: threshold to consider the system at steady state",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "30",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "isotonic regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.isotonic.IsotonicRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "min_fit",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "If not None, set the lowest value of the fit to min_fit",
            "scikit-learn": {
              "default_value": "None",
              "path": "y_min"
            }
          },
          {
            "name": "max_fit",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "If not None, set the highest value of the fit to max_fit",
            "scikit-learn": {
              "default_value": "None",
              "path": "y_max"
            }
          },
          {
            "name": "increasing",
            "kind_of_value": "{'auto', boolean}",
            "optional": "True",
            "description": "If boolean, whether or not to fit the isotonic regression with outputs increasing or decreasing. The string value “auto” determines whether outputs should increase or decrease based on the Spearman correlation estimate’s sign.",
            "scikit-learn": {
              "default_value": "True",
              "path": "increasing"
            }
          },
          {
            "name": "out_of_bounds",
            "kind_of_value": "{'nan, 'clip', 'raise'}",
            "optional": "True",
            "description": "Defines how input-values outside the training domain should be handled. 'nan' set predictions to NaN, 'clip' set predicted values to the value corresponding to the nearest train interval endpoint. 'raise' allows to throw a ValueError.",
            "scikit-learn": {
              "default_value": "'nan'",
              "path": "out_of_bounds"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "probability calibration with cross validation",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.calibration.CalibratedClassifierCV"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "False",
            "description": "The classifier whose output decision function needs to be calibrated to offer more accurate prediction probability outputs. ",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "calibration_method",
            "kind_of_value": "{'sigmoid', 'isotonic'}",
            "optional": "False",
            "description": "The method to use for calibration.",
            "scikit-learn": {
              "default_value": "'sigmoid'",
              "path": "method"
            }
          },
          {
            "name": "cross-validation",
            "kind_of_value": "{integer, object (cross-validation generator),  iterable yielding train and test splits, None, 'prefit'",
            "optional": "True",
            "description": "Determines the cross-validation splitting strategy.",
            "scikit-learn": {
              "default_value": "3",
              "path": "cv"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "Brier score",
      "other_names": [],
      "implementation": {
        "scikit-learn": ""
      },
      "type": "Scoring Function",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "true_targets",
            "kind_of_value": "array, shape (n_samples)",
            "optional": "False",
            "description": "True targets.",
            "scikit-learn": {
              "default_value": "",
              "path": "y_true"
            }
          },
          {
            "name": "positive_probabilities",
            "kind_of_value": "array, shape (n_samples)",
            "optional": "False",
            "description": "Probabilities of the positive class.",
            "scikit-learn": {
              "default_value": "",
              "path": "y_prob"
            }
          },
          {
            "name": "sample_weight",
            "kind_of_value": "{array, shape (n_samples), None}",
            "optional": "True",
            "description": "Sample weights.",
            "scikit-learn": {
              "default_value": "None",
              "path": "sample_weight"
            }
          },
          {
            "name": "positive_label",
            "kind_of_value": "{integer, string}",
            "optional": "False",
            "description": "Label of the positive class. If None, the maximum label is used as positive class",
            "scikit-learn": {
              "default_value": "None",
              "path": "pos_label"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "multi-layer perceptron regressor",
      "other_names": ["MLP regressor"],
      "implementation": {
        "scikit-learn": "sklearn.neural_network.MLPRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "hidden_layer_sizes",
            "kind_of_value": "tuple, length = n_layers - 2",
            "optional": "False",
            "description": "The ith element represents the number of neurons in the ith hidden layer.",
            "scikit-learn": {
              "default_value": "(100,)",
              "path": "hidden_layer_sizes"
            }
          },
          {
            "name": "activation",
            "kind_of_value": " {'identity', 'logistic', 'tanh', 'relu'}",
            "optional": "False",
            "description": "Activation function for the hidden layer.",
            "scikit-learn": {
              "default_value": "'relu'",
              "path": "activation"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{'lbfgs', 'sgd', 'adam'}",
            "optional": "False",
            "description": "The solver for weight optimization.",
            "scikit-learn": {
              "default_value": "'adam'",
              "path": "solver"
            }
          },
          {
            "name": "l2_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "L2 penalty (regularization term) parameter.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "{integer, 'auto'}",
            "optional": "True",
            "description": "Size of minibatches for stochastic optimizers.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "batch_size"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{'constant', 'invscaling', 'adaptive'}",
            "optional": "False",
            "description": "Learning rate schedule for weight updates.",
            "scikit-learn": {
              "default_value": "'constant'",
              "path": "learning_rate"
            }
          },
          {
            "name": "learning_rate_init",
            "kind_of_value": "double",
            "optional": "True",
            "description": "The initial learning rate used. It controls the step-size in updating the weights.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "learning_rate_init"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "True",
            "description": "The exponent for inverse scaling learning rate.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "power_t"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to shuffle samples in each iteration.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "gradient_momentum",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Momentum for gradient descent update.",
            "scikit-learn": {
              "default_value": "0.9",
              "path": "momentum"
            }
          },
          {
            "name": "nesterovs_momentum",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use Nesterov’s momentum.",
            "scikit-learn": {
              "default_value": "True",
              "path": "nesterovs_momentum"
            }
          },
          {
            "name": "early_stopping",
            "kind_of_value": "boolean",
            "optional": "Flase",
            "description": "Whether to use early stopping to terminate training when validation score is not improving. If set to true, it will automatically set aside 10% of training data as validation and terminate training when validation score is not improving by at least tol for two consecutive epochs.",
            "scikit-learn": {
              "default_value": "Flase",
              "path": "early_stopping"
            }
          },
          {
            "name": "validation_fraction",
            "kind_of_value": "float between 0 and 1",
            "optional": "True",
            "description": "The proportion of training data to set aside as validation set for early stopping.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "validation_fraction"
            }
          },
          {
            "name": "adam_beta_1",
            "kind_of_value": "float should be in [0, 1)",
            "optional": "True",
            "description": "Exponential decay rate for estimates of first moment vector in adam.",
            "scikit-learn": {
              "default_value": "0.9",
              "path": "beta_1"
            }
          },
          {
            "name": "adam_beta_2",
            "kind_of_value": "float should be in [0, 1)",
            "optional": "True",
            "description": "Exponential decay rate for estimates of second moment vector in adam.",
            "scikit-learn": {
              "default_value": "0.999",
              "path": "beta_2"
            }
          },
          {
            "name": "adam_epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Value for numerical stability in adam.",
            "scikit-learn": {
              "default_value": "0.00000001",
              "path": "epsilon"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "200",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "multi-layer perceptron classifier",
      "other_names": ["MLP classifier"],
      "implementation": {
        "scikit-learn": "sklearn.neural_network.MLPClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "hidden_layer_sizes",
            "kind_of_value": "tuple, length = n_layers - 2",
            "optional": "False",
            "description": "The ith element represents the number of neurons in the ith hidden layer.",
            "scikit-learn": {
              "default_value": "(100,)",
              "path": "hidden_layer_sizes"
            }
          },
          {
            "name": "activation",
            "kind_of_value": " {'identity', 'logistic', 'tanh', 'relu'}",
            "optional": "False",
            "description": "Activation function for the hidden layer.",
            "scikit-learn": {
              "default_value": "'relu'",
              "path": "activation"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{'lbfgs', 'sgd', 'adam'}",
            "optional": "False",
            "description": "The solver for weight optimization.",
            "scikit-learn": {
              "default_value": "'adam'",
              "path": "solver"
            }
          },
          {
            "name": "l2_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "L2 penalty (regularization term) parameter.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "{integer, 'auto'}",
            "optional": "True",
            "description": "Size of minibatches for stochastic optimizers.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "batch_size"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{'constant', 'invscaling', 'adaptive'}",
            "optional": "False",
            "description": "Learning rate schedule for weight updates.",
            "scikit-learn": {
              "default_value": "'constant'",
              "path": "learning_rate"
            }
          },
          {
            "name": "learning_rate_init",
            "kind_of_value": "double",
            "optional": "True",
            "description": "The initial learning rate used. It controls the step-size in updating the weights.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "learning_rate_init"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "True",
            "description": "The exponent for inverse scaling learning rate.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "power_t"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to shuffle samples in each iteration.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "gradient_momentum",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Momentum for gradient descent update.",
            "scikit-learn": {
              "default_value": "0.9",
              "path": "momentum"
            }
          },
          {
            "name": "nesterovs_momentum",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use Nesterov’s momentum.",
            "scikit-learn": {
              "default_value": "True",
              "path": "nesterovs_momentum"
            }
          },
          {
            "name": "early_stopping",
            "kind_of_value": "boolean",
            "optional": "Flase",
            "description": "Whether to use early stopping to terminate training when validation score is not improving. If set to true, it will automatically set aside 10% of training data as validation and terminate training when validation score is not improving by at least tol for two consecutive epochs.",
            "scikit-learn": {
              "default_value": "Flase",
              "path": "early_stopping"
            }
          },
          {
            "name": "validation_fraction",
            "kind_of_value": "float between 0 and 1",
            "optional": "True",
            "description": "The proportion of training data to set aside as validation set for early stopping.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "validation_fraction"
            }
          },
          {
            "name": "adam_beta_1",
            "kind_of_value": "float should be in [0, 1)",
            "optional": "True",
            "description": "Exponential decay rate for estimates of first moment vector in adam.",
            "scikit-learn": {
              "default_value": "0.9",
              "path": "beta_1"
            }
          },
          {
            "name": "adam_beta_2",
            "kind_of_value": "float should be in [0, 1)",
            "optional": "True",
            "description": "Exponential decay rate for estimates of second moment vector in adam.",
            "scikit-learn": {
              "default_value": "0.999",
              "path": "beta_2"
            }
          },
          {
            "name": "adam_epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Value for numerical stability in adam.",
            "scikit-learn": {
              "default_value": "0.00000001",
              "path": "epsilon"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "200",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "Gaussian mixture",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.mixture.GaussianMixture"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of mixture components.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_components"
            }
          },
          {
            "name": "covariance_type",
            "kind_of_value": "{'full', 'tied', 'diag', 'spherical'}",
            "optional": "False",
            "description": "String describing the type of covariance parameters to use.",
            "scikit-learn": {
              "default_value": "'full'",
              "path": "covariance_type"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The convergence threshold.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "reg_covariance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Non-negative regularization added to the diagonal of covariance. Allows to assure that the covariance matrices are all positive.",
            "scikit-learn": {
              "default_value": "0.000001",
              "path": "reg_covar"
            }
          },
          {
            "name": "init_params",
            "kind_of_value": "{'kmeans', 'random'}",
            "optional": "False",
            "description": "The method used to initialize the weights, the means and the precisions.",
            "scikit-learn": {
              "default_value": "'kmeans'",
              "path": "init_params"
            }
          },
          {
            "name": "weights_init",
            "kind_of_value": "{array-like, shape (n_components, ), None}",
            "optional": "True",
            "description": "The user-provided initial weights.",
            "scikit-learn": {
              "default_value": "None",
              "path": "weights_init"
            }
          },
          {
            "name": "means_init",
            "kind_of_value": "{array-like, shape (n_components,  n_features), None}",
            "optional": "True",
            "description": "The user-provided initial means.",
            "scikit-learn": {
              "default_value": "None",
              "path": "means_init"
            }
          },
          {
            "name": "precisions_init",
            "kind_of_value": "{array-like depending on 'covariance_type': (n_components,) if 'spherical', (n_features, n_features) if 'tied', (n_components, n_features) if 'diag',(n_components, n_features, n_features) if 'full', None}",
            "optional": "True",
            "description": "The user-provided initial precisions (inverse of the covariance matrices).",
            "scikit-learn": {
              "default_value": "None",
              "path": "precisions_init"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "num_initializations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of initializations to perform. The best results are kept.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_init"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "Bayesian Gaussian mixture",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.mixture.BayesianGaussianMixture"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of mixture components.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_components"
            }
          },
          {
            "name": "covariance_type",
            "kind_of_value": "{'full', 'tied', 'diag', 'spherical'}",
            "optional": "False",
            "description": "String describing the type of covariance parameters to use.",
            "scikit-learn": {
              "default_value": "'full'",
              "path": "covariance_type"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The convergence threshold.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "reg_covariance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Non-negative regularization added to the diagonal of covariance. Allows to assure that the covariance matrices are all positive.",
            "scikit-learn": {
              "default_value": "0.000001",
              "path": "reg_covar"
            }
          },
          {
            "name": "init_params",
            "kind_of_value": "{'kmeans', 'random'}",
            "optional": "False",
            "description": "The method used to initialize the weights, the means and the precisions.",
            "scikit-learn": {
              "default_value": "'kmeans'",
              "path": "init_params"
            }
          },
          {
            "name": "weight_concentration_prior_type",
            "kind_of_value": "{'dirichlet_process', 'dirichlet_distribution'}",
            "optional": "False",
            "description": "String describing the type of the weight concentration prior.",
            "scikit-learn": {
              "default_value": "'dirichlet_process'",
              "path": "weight_concentration_prior_type"
            }
          },
          {
            "name": "weight_concentration_prior",
            "kind_of_value": "{float > 0, None}",
            "optional": "True",
            "description": "The dirichlet concentration of each component on the weight distribution (Dirichlet). This is commonly called gamma in the literature. The higher concentration puts more mass in the center and will lead to more components being active, while a lower concentration parameter will lead to more mass at the edge of the mixture weights simplex.",
            "scikit-learn": {
              "default_value": "None",
              "path": "weight_concentration_prior"
            }
          },
          {
            "name": "mean_precision_prior",
            "kind_of_value": "{float > 0, None}",
            "optional": "True",
            "description": "The precision prior on the mean distribution (Gaussian). Controls the extend to where means can be placed. Smaller values concentrate the means of each clusters around mean_prior.",
            "scikit-learn": {
              "default_value": "None",
              "path": "mean_precision_prior"
            }
          },
          {
            "name": "mean_prior",
            "kind_of_value": "{array-like, shape (n_features, ), None}",
            "optional": "True",
            "description": "The prior on the mean distribution (Gaussian).",
            "scikit-learn": {
              "default_value": "None",
              "path": "mean_prior"
            }
          },
          {
            "name": "degrees_of_freedom_prior",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "The prior of the number of degrees of freedom on the covariance distributions (Wishart). ",
            "scikit-learn": {
              "default_value": "None",
              "path": "degrees_of_freedom_prior"
            }
          },
          {
            "name": "covariance_prior",
            "kind_of_value": "{array-like depending on 'covariance_type': float if 'spherical', (n_features, n_features) if 'tied', (n_features, ) if 'diag',(n_features, n_features) if 'full', None}",
            "optional": "True",
            "description": "The user-provided initial precisions (inverse of the covariance matrices).",
            "scikit-learn": {
              "default_value": "None",
              "path": "covariance_prior"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "num_initializations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of initializations to perform. The best results are kept.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_init"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "isomap embedding",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.manifold.Isomap"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of neighbors to consider for each point.",
            "scikit-learn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of coordinates for the manifold.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'auto', 'arpack', 'dense']",
            "optional": "False",
            "description": "Solver for the eigenvalue decomposition.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "eigen_solver"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Tolerance passed to the eigenvalue decomposition solver",
            "scikit-learn": {
              "default_value": "0",
              "path": "tol"
            }
          },
          {
            "name": "path_method",
            "kind_of_value": "{'auto', 'FW', 'D'}",
            "optional": "False",
            "description": "Method to use in finding shortest path. 'auto' : attempt to choose the best algorithm automatically. 'FW' : Floyd-Warshall algorithm. 'D' : Dijkstra’s algorithm.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "path_method"
            }
          },
          {
            "name": "neighbors_algorithm",
            "kind_of_value": "{'auto', 'brute', 'kd_tree', 'ball_tree'}",
            "optional": "False",
            "description": "Algorithm to use for nearest neighbors search, passed to neighbors. NearestNeighbors instance.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "neighbors_algorithm"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations for eigenvalue decomposition solver.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "locally linear embedding analysis",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.manifold.locally_linear_embedding"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [

          {
            "name": "sample_data",
            "kind_of_value": "{array-like shape (n_samples, n_features), sparse matrix, BallTree, KDTree, NearestNeighbors}",
            "optional": "False",
            "description": "Sample data.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of neighbors to consider for each point.",
            "scikit-learn": {
              "default_value": "",
              "path": "n_neighbors"
            }
          },
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of coordinates for the manifold.",
            "scikit-learn": {
              "default_value": "",
              "path": "n_components"
            }
          },
          {
            "name": "regularization_constant",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Regularization constant, multiplies the trace of the local covariance matrix of the distances.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "reg"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'auto', 'arpack', 'dense']",
            "optional": "False",
            "description": "Solver for the eigenvalue decomposition.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "eigen_solver"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance passed to the eigenvalue decomposition solver",
            "scikit-learn": {
              "default_value": "0.000001",
              "path": "tol"
            }
          },
          {
            "name": "embedding_method",
            "kind_of_value": "{'standard', 'hessian', 'modified', 'ltsa'}",
            "optional": "False",
            "description": "Embedding method.",
            "scikit-learn": {
              "default_value": "'standard'",
              "path": "method"
            }
          },
          {
            "name": "hessian_tol",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for Hessian eigenmapping method.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "hessian_tol"
            }
          },
          {
            "name": "modified_tol",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for modified LLE method.",
            "scikit-learn": {
              "default_value": "0.000000000001",
              "path": "modified_tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations for eigenvalue decomposition solver.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "object oriented locally linear embedding analysis",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.manifold.LocallyLinearEmbedding"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of neighbors to consider for each point.",
            "scikit-learn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of coordinates for the manifold.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "regularization_constant",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Regularization constant, multiplies the trace of the local covariance matrix of the distances.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "reg"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'auto', 'arpack', 'dense']",
            "optional": "False",
            "description": "Solver for the eigenvalue decomposition.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "eigen_solver"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance passed to the eigenvalue decomposition solver",
            "scikit-learn": {
              "default_value": "0.000001",
              "path": "tol"
            }
          },
          {
            "name": "embedding_method",
            "kind_of_value": "{'standard', 'hessian', 'modified', 'ltsa'}",
            "optional": "False",
            "description": "Embedding method.",
            "scikit-learn": {
              "default_value": "'standard'",
              "path": "method"
            }
          },
          {
            "name": "hessian_tol",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for Hessian eigenmapping method.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "hessian_tol"
            }
          },
          {
            "name": "modified_tol",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for modified LLE method.",
            "scikit-learn": {
              "default_value": "0.000000000001",
              "path": "modified_tol"
            }
          },
          {
            "name": "neighbors_algorithm",
            "kind_of_value": "{'auto', 'brute', 'kd_tree', 'ball_tree'}",
            "optional": "False",
            "description": "Algorithm to use for nearest neighbors search, passed to neighbors.NearestNeighbors instance.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "neighbors_algorithm"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations for eigenvalue decomposition solver.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "multidimensional scaling",
      "other_names": ["MDS"],
      "implementation": {
        "scikit-learn": "sklearn.manifold.MDS"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of coordinates for the manifold.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "metric_MDS",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, perform metric MDS; otherwise, perform nonmetric MDS.",
            "scikit-learn": {
              "default_value": "True",
              "path": "metric"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Level of verbosity.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "eps",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Relative tolerance with respect to stress at which to declare convergence.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "eps"
            }
          },
          {
            "name": "dissimilarity",
            "kind_of_value": "{'euclidean', 'precomputed'}",
            "optional": "True",
            "description": "Dissimilarity measure to use.",
            "scikit-learn": {
              "default_value": "'euclidean'",
              "path": "dissimilarity"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations of the SMACOF algorithm for a single run.",
            "scikit-learn": {
              "default_value": "300",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          },
          {
            "name": "num_initializations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of times the SMACOF algorithm will be run with different initializations. The final results will be the best output of the runs, determined by the run with the smallest final stress.",
            "scikit-learn": {
              "default_value": "4",
              "path": "n_init"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "spectral embedding",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.manifold.spectral_embedding"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "adjacency_matrix",
            "kind_of_value": "array-like or sparse matrix, shape: (n_samples, n_samples)",
            "optional": "False",
            "description": "The adjacency matrix of the graph to embed.",
            "scikit-learn": {
              "default_value": "",
              "path": "adjacency"
            }
          },
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The dimension of the projection subspace.",
            "scikit-learn": {
              "default_value": "8",
              "path": "n_components"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'arpack', 'lobpcg', 'amg', None}",
            "optional": "False",
            "description": "Solver for the eigenvalue decomposition.",
            "scikit-learn": {
              "default_value": "None",
              "path": "eigen_solver"
            }
          },
          {
            "name": "eigen_tol",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "eigen_tol"
            }
          },
          {
            "name": "norm_laplacian",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, then compute normalized Laplacian.",
            "scikit-learn": {
              "default_value": "True",
              "path": "norm_laplacian"
            }
          },
          {
            "name": "drop_first",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to drop the first eigenvector. For spectral embedding, this should be True as the first eigenvector should be constant vector for connected graph, but for spectral clustering, this should be kept as False to retain the first eigenvector.",
            "scikit-learn": {
              "default_value": "True",
              "path": "drop_first"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "object oriented spectral embedding",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.manifold.SpectralEmbedding"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The dimension of the projection subspace.",
            "scikit-learn": {
              "default_value": "8",
              "path": "n_components"
            }
          },
          {
            "name": "affinity_matrix",
            "kind_of_value": "{'nearest_neighbors', 'rbf', 'precomputed', callable: use passed in function as affinity the function takes in data matrix (n_samples, n_features) and return affinity matrix (n_samples, n_samples)}",
            "optional": "False",
            "description": "How to construct the affinity matrix.",
            "scikit-learn": {
              "default_value": "'nearest_neighbors'",
              "path": "affinity"
            }
          },
          {
            "name": "gamma",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "Kernel coefficient for rbf kernel.",
            "scikit-learn": {
              "default_value": "None",
              "path": "gamma"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'arpack', 'lobpcg', 'amg', None}",
            "optional": "False",
            "description": "Solver for the eigenvalue decomposition.",
            "scikit-learn": {
              "default_value": "None",
              "path": "eigen_solver"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Number of nearest neighbors for nearest_neighbors graph building.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_neighbors"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "t-distributed stochastic neighbor embedding",
      "other_names": ["TSNE", "t-SNE"],
      "implementation": {
        "scikit-learn": "sklearn.manifold.TSNE"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The dimension of the projection subspace.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "perplexity",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The perplexity is related to the number of nearest neighbors that is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity. Consider selecting a value between 5 and 50. The choice is not extremely critical since t-SNE is quite insensitive to this parameter.",
            "scikit-learn": {
              "default_value": "30",
              "path": "perplexity"
            }
          },
          {
            "name": "early_exaggeration",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Controls how tight natural clusters in the original space are in the embedded space and how much space will be between them. For larger values, the space between natural clusters will be larger in the embedded space. Again, the choice of this parameter is not very critical. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high.",
            "scikit-learn": {
              "default_value": "12.0",
              "path": "early_exaggeration"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The learning rate for t-SNE is usually in the range [10.0, 1000.0]. If the learning rate is too high, the data may look like a ‘ball’ with any point approximately equidistant from its nearest neighbours. If the learning rate is too low, most points may look compressed in a dense cloud with few outliers. If the cost function gets stuck in a bad local minimum increasing the learning rate may help.",
            "scikit-learn": {
              "default_value": "200.0",
              "path": "learning_rate"
            }
          },
          {
            "name": "min_grad_norm",
            "kind_of_value": "float",
            "optional": "True",
            "description": "If the gradient norm is below this threshold, the optimization will be stopped.",
            "scikit-learn": {
              "default_value": "0.0000001",
              "path": "min_grad_norm"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The metric to use when calculating distance between instances in a feature array.",
            "scikit-learn": {
              "default_value": "'euclidean'",
              "path": "metric"
            }
          },
          {
            "name": "initialisation",
            "kind_of_value": "{'random', 'pca', numpy array of shape (n_samples, n_components)}",
            "optional": "True",
            "description": "Initialization of embedding.",
            "scikit-learn": {
              "default_value": "'random'",
              "path": "init"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity level.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "optimisation_method",
            "kind_of_value": "{'barnes_hut', 'exact'}",
            "optional": "False",
            "description": "Gradient calculation algorithm optimisation.",
            "scikit-learn": {
              "default_value": "'barnes_hut'",
              "path": "method"
            }
          },
          {
            "name": "angle",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The angular size of a distant node as measured from a point. If this size is below 'angle' then it is used as a summary node of all points contained within it. This method is not very sensitive to changes in this parameter in the range of 0.2 - 0.8. Angle less than 0.2 has quickly increasing computation time and angle greater 0.8 has quickly increasing error.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "angle"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations for the optimization.",
            "scikit-learn": {
              "default_value": "1000",
              "path": "n_iter"
            }
          },
          {
            "name": "max_iterations_without_progress",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations without progress before we abort the optimization, used after 250 initial iterations with early exaggeration. Note that progress is only checked every 50 iterations so this value is rounded to the next multiple of 50.",
            "scikit-learn": {
              "default_value": "300",
              "path": "n_iter_without_progress"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "k-means clustering",
      "other_names": ["Lloyd’s algorithm"],
      "implementation": {
        "scikit-learn": "sklearn.cluster.KMeans"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of clusters to form as well as the number of centroids to generate.",
            "scikit-learn": {
              "default_value": "8",
              "path": "n_clusters"
            }
          },
          {
            "name": "initialization_method",
            "kind_of_value": "{'k-means++', 'random',  array of shape (n_clusters, n_features)}",
            "optional": "False",
            "description": "Method for initialization.",
            "scikit-learn": {
              "default_value": "'k-means++'",
              "path": "init"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Relative tolerance with regards to inertia to declare convergence",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Verbosity mode.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "algorithm",
            "kind_of_value": "{'auto', 'full', 'elkan'}",
            "optional": "False",
            "description": "K-means algorithm to use.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "num_initialization",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of time the k-means algorithm will be run with different centroid seeds.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_init"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations of the k-means algorithm for a single run.",
            "scikit-learn": {
              "default_value": "300",
              "path": "max_iter"
            }
          },
          {
            "name": "precompute_distances",
            "kind_of_value": "{'auto', True, False}",
            "optional": "False",
            "description": "Precompute distances (faster but takes more memory). ‘auto’ : do not precompute distances if n_samples * n_clusters > 12 million. This corresponds to about 100MB overhead per job using double precision.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "precompute_distances"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "mini batch k-means clustering",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.cluster.MiniBatchKMeans"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of clusters to form as well as the number of centroids to generate.",
            "scikit-learn": {
              "default_value": "8",
              "path": "n_clusters"
            }
          },
          {
            "name": "initialization_method",
            "kind_of_value": "{'k-means++', 'random',  array of shape (n_clusters, n_features)}",
            "optional": "False",
            "description": "Method for initialization.",
            "scikit-learn": {
              "default_value": "'k-means++'",
              "path": "init"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Size of the mini batches.",
            "scikit-learn": {
              "default_value": "100",
              "path": "batch_size"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Verbosity mode.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "compute_labels",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Compute label assignment and inertia for the complete dataset once the minibatch optimization has converged in fit.",
            "scikit-learn": {
              "default_value": "True",
              "path": "compute_labels"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Control early stopping based on the relative center changes as measured by a smoothed, variance-normalized of the mean center squared position changes. This early stopping heuristics is closer to the one used for the batch variant of the algorithms but induces a slight computational and memory overhead over the inertia heuristic.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations over the complete dataset before stopping independently of any early stopping criterion heuristics.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "max_no_improvement",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Control early stopping based on the consecutive number of mini batches that does not yield an improvement on the smoothed inertia.",
            "scikit-learn": {
              "default_value": "10",
              "path": "max_no_improvement"
            }
          },
          {
            "name": "initialization_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of samples to randomly sample for speeding up the initialization (sometimes at the expense of accuracy).",
            "scikit-learn": {
              "default_value": "3*batch size",
              "path": "init_size"
            }
          },
          {
            "name": "num_initialization",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of random initializations that are tried.",
            "scikit-learn": {
              "default_value": "3",
              "path": "n_init"
            }
          },
          {
            "name": "reassignment_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Control the fraction of the maximum number of counts for a center to be reassigned. A higher value means that low count centers are more easily reassigned, which means that the model will take longer to converge, but should converge in a better clustering.",
            "scikit-learn": {
              "default_value": "0.01",
              "path": "reassignment_ratio"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "affinity propagation clustering",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.cluster.AffinityPropagation"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "damping",
            "kind_of_value": "float (between 0.5 and 1)",
            "optional": "",
            "description": "Damping factor is the extent to which the current value is maintained relative to incoming values (weighted 1 - damping). This in order to avoid numerical oscillations when updating these values (messages).",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "damping"
            }
          },
          {
            "name": "preference",
            "kind_of_value": "{array-like, shape (n_samples,), float, None}",
            "optional": "True",
            "description": "Preferences for each point - points with larger values of preferences are more likely to be chosen as exemplars. The number of exemplars, ie of clusters, is influenced by the input preferences value. If the preferences are not passed as arguments, they will be set to the median of the input similarities.",
            "scikit-learn": {
              "default_value": "None",
              "path": "preference"
            }
          },
          {
            "name": "affinity",
            "kind_of_value": "{'precomputed', 'euclidean'}'",
            "optional": "True",
            "description": "Which affinity to use.",
            "scikit-learn": {
              "default_value": "'euclidean'",
              "path": "affinity"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to be verbose.",
            "scikit-learn": {
              "default_value": "False",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations over the complete dataset before stopping independently of any early stopping criterion heuristics.",
            "scikit-learn": {
              "default_value": "200",
              "path": "max_iter"
            }
          },
          {
            "name": "convergence_iteration",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of iterations with no change in the number of estimated clusters that stops the convergence.",
            "scikit-learn": {
              "default_value": "15",
              "path": "convergence_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "mean shift clustering with flat kernel",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.cluster.MeanShift"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "bandwidth",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "Bandwidth used in the RBF kernel.",
            "scikit-learn": {
              "default_value": "None",
              "path": "bandwidth"
            }
          },
          {
            "name": "seeds",
            "kind_of_value": "{array of shape=[n_samples, n_features], None}",
            "optional": "True",
            "description": "Seeds used to initialize kernels.",
            "scikit-learn": {
              "default_value": "None",
              "path": "seeds"
            }
          },
          {
            "name": "bin_seeding",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If true, initial kernel locations are not locations of all points, but rather the location of the discretized version of points, where points are binned onto a grid whose coarseness corresponds to the bandwidth. Setting this option to True will speed up the algorithm because fewer seeds will be initialized.",
            "scikit-learn": {
              "default_value": "False",
              "path": "bin_seeding"
            }
          },
          {
            "name": "min_bin_freq",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "To speed up the algorithm, accept only those bins with at least min_bin_freq points as seeds.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_bin_freq"
            }
          },
          {
            "name": "cluster_all",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "If true, then all points are clustered, even those orphans that are not within any kernel. Orphans are assigned to the nearest kernel. If false, then orphans are given cluster label -1.",
            "scikit-learn": {
              "default_value": "True",
              "path": "cluster_all"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "spectral clustering",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.cluster.SpectralClustering"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The dimension of the projection subspace.",
            "scikit-learn": {
              "default_value": "8",
              "path": "n_clusters"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'lobpcg', 'arpack', 'amg', None]",
            "optional": "False",
            "description": "The eigenvalue decomposition strategy to use.",
            "scikit-learn": {
              "default_value": "None",
              "path": "eigen_solver"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels.",
            "scikit-learn": {
              "default_value": "10",
              "path": "gamma"
            }
          },
          {
            "name": "affinity",
            "kind_of_value": "{'nearest_neighbors', 'precomputed', 'rbf', 'sigmoid', 'polynomial', 'poly', 'linear', 'cosine', array-like, callable}'",
            "optional": "True",
            "description": "Which affinity to use.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "affinity"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use when constructing the affinity matrix using the nearest neighbors method.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_neighbors"
            }
          },
          {
            "name": "eigen_tol",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "eigen_tol"
            }
          },
          {
            "name": "assign_labels",
            "kind_of_value": "{'kmeans', 'discretize'}",
            "optional": "False",
            "description": "The strategy to use to assign labels in the embedding space. There are two ways to assign labels after the laplacian embedding. k-means can be applied and is a popular choice. But it can also be sensitive to initialization. Discretization is another approach which is less sensitive to random initialization.",
            "scikit-learn": {
              "default_value": "'kmeans'",
              "path": "assign_labels"
            }
          },
          {
            "name": "kernel_degree",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Degree of the polynomial kernel.",
            "scikit-learn": {
              "default_value": "3.0",
              "path": "degree"
            }
          },
          {
            "name": "zero_coefficient",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Zero coefficient for polynomial and sigmoid kernels.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "coef0"
            }
          },
          {
            "name": "kernel_parameters",
            "kind_of_value": "dictionary of string to any",
            "optional": "True",
            "description": "Additional parameters (keyword arguments) for kernel function passed as callable object.",
            "scikit-learn": {
              "default_value": "None",
              "path": "kernel_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          },
          {
            "name": "num_initialization",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of time the k-means algorithm will be run with different centroid seeds.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_init"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "agglomerative clustering",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.cluster.AgglomerativeClustering"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of clusters to find.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_clusters"
            }
          },
          {
            "name": "affinity",
            "kind_of_value": "{'precomputed', 'euclidean', 'l1', 'l2', 'manhattan', 'cosine'}'",
            "optional": "False",
            "description": "Which affinity to use.",
            "scikit-learn": {
              "default_value": "'euclidean'",
              "path": "affinity"
            }
          },
          {
            "name": "connectivity_matrix",
            "kind_of_value": "{array-like, callable, None}",
            "optional": "True",
            "description": "Connectivity matrix. Defines for each sample the neighboring samples following a given structure of the data. This can be a connectivity matrix itself or a callable that transforms the data into a connectivity matrix.",
            "scikit-learn": {
              "default_value": "None",
              "path": "connectivity"
            }
          },
          {
            "name": "compute_full_tree",
            "kind_of_value": "{boolean, 'auto'}",
            "optional": "True",
            "description": "Stop early the construction of the tree at num_clusters. This is useful to decrease computation time if the number of clusters is not small compared to the number of samples. This option is useful only when specifying a connectivity matrix. Note also that when varying the number of clusters and using caching, it may be advantageous to compute the full tree.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "compute_full_tree"
            }
          },
          {
            "name": "linkage_criterion",
            "kind_of_value": "{'ward', 'complete', 'average'}",
            "optional": "True",
            "description": "Which linkage criterion to use. The linkage criterion determines which distance to use between sets of observation. The algorithm will merge the pairs of cluster that minimize this criterion.",
            "scikit-learn": {
              "default_value": "'ward'",
              "path": "linkage"
            }
          },
          {
            "name": "pooling_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "This combines the values of agglomerated features into a single value, and should accept an array of shape [M, N] and the keyword argument axis=1, and reduce it to an array of size [M].",
            "scikit-learn": {
              "default_value": "<function mean>",
              "path": "pooling_func"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "feature agglomerative clustering",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.cluster.FeatureAgglomeration"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of clusters to find.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_clusters"
            }
          },
          {
            "name": "affinity",
            "kind_of_value": "{'precomputed', 'euclidean', 'l1', 'l2', 'manhattan', 'cosine'}'",
            "optional": "False",
            "description": "Which affinity to use.",
            "scikit-learn": {
              "default_value": "'euclidean'",
              "path": "affinity"
            }
          },
          {
            "name": "connectivity_matrix",
            "kind_of_value": "{array-like, callable, None}",
            "optional": "True",
            "description": "Connectivity matrix. Defines for each sample the neighboring samples following a given structure of the data. This can be a connectivity matrix itself or a callable that transforms the data into a connectivity matrix.",
            "scikit-learn": {
              "default_value": "None",
              "path": "connectivity"
            }
          },
          {
            "name": "compute_full_tree",
            "kind_of_value": "{boolean, 'auto'}",
            "optional": "True",
            "description": "Stop early the construction of the tree at num_clusters. This is useful to decrease computation time if the number of clusters is not small compared to the number of samples. This option is useful only when specifying a connectivity matrix. Note also that when varying the number of clusters and using caching, it may be advantageous to compute the full tree.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "compute_full_tree"
            }
          },
          {
            "name": "linkage_criterion",
            "kind_of_value": "{'ward', 'complete', 'average'}",
            "optional": "True",
            "description": "Which linkage criterion to use. The linkage criterion determines which distance to use between sets of observation. The algorithm will merge the pairs of cluster that minimize this criterion.",
            "scikit-learn": {
              "default_value": "'ward'",
              "path": "linkage"
            }
          },
          {
            "name": "pooling_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "This combines the values of agglomerated features into a single value, and should accept an array of shape [M, N] and the keyword argument axis=1, and reduce it to an array of size [M].",
            "scikit-learn": {
              "default_value": "<function mean>",
              "path": "pooling_func"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "DBSCAN",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.cluster.DBSCAN"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "eps",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The maximum distance between two samples for them to be considered as in the same neighborhood.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "eps"
            }
          },
          {
            "name": "min_samples",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of samples (or total weight) in a neighborhood for a point to be considered as a core point. This includes the point itself.",
            "scikit-learn": {
              "default_value": "5",
              "path": "min_samples"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The metric to use when calculating distance between instances in a feature array.",
            "scikit-learn": {
              "default_value": "'euclidean'",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          },
          {
            "name": "algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "The algorithm to be used by the NearestNeighbors module to compute pointwise distances and find nearest neighbors. See NearestNeighbors module documentation for details.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The power of the Minkowski metric to be used to calculate distance between points.",
            "scikit-learn": {
              "default_value": "None",
              "path": "p"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "birch clustering",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.cluster.Birch"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "threshold",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The radius of the subcluster obtained by merging a new sample and the closest subcluster should be lesser than the threshold. Otherwise a new subcluster is started. Setting this value to be very low promotes splitting and vice-versa.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "threshold"
            }
          },
          {
            "name": "branching_factor",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of CF subclusters in each node. If a new samples enters such that the number of subclusters exceed the branching_factor then that node is split into two nodes with the subclusters redistributed in each. The parent subcluster of that node is removed and two new subclusters are added as parents of the 2 split nodes.",
            "scikit-learn": {
              "default_value": "50",
              "path": "branching_factor"
            }
          },
          {
            "name": "num_clusters",
            "kind_of_value": "{integer, instance of sklearn.cluster model, None}",
            "optional": "False",
            "description": "Number of clusters after the final clustering step, which treats the subclusters from the leaves as new samples.",
            "scikit-learn": {
              "default_value": "3",
              "path": "n_clusters"
            }
          },
          {
            "name": "compute_labels",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether or not to compute labels for each fit.",
            "scikit-learn": {
              "default_value": "True",
              "path": "compute_labels"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "",
            "kind_of_value": "",
            "optional": "",
            "description": "",
            "scikit-learn": {
              "default_value": "",
              "path": ""
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "adjusted rand index",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.metrics.adjusted_rand_score"
      },
      "type": "Similarity Measure",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "labels_true",
            "kind_of_value": "integer array, shape = [n_samples]",
            "optional": "False",
            "description": "Ground truth class labels to be used as a reference",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_true"
            }
          },
          {
            "name": "labels_pred",
            "kind_of_value": "array, shape = [n_samples]",
            "optional": "False",
            "description": "Cluster labels to evaluate",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_pred"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "mutual information score",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.metrics.mutual_info_score"
      },
      "type": "Similarity Measure",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "labels_true",
            "kind_of_value": "integer array, shape = [n_samples]",
            "optional": "False",
            "description": "Ground truth class labels to be used as a reference",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_true"
            }
          },
          {
            "name": "labels_pred",
            "kind_of_value": "array, shape = [n_samples]",
            "optional": "False",
            "description": "Cluster labels to evaluate",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_pred"
            }
          },
          {
            "name": "contingency",
            "kind_of_value": "{None, array shape = [n_classes_true, n_classes_pred], sparse matrix shape = [n_classes_true, n_classes_pred]}",
            "optional": "False",
            "description": "A contingency matrix given by the contingency_matrix function.",
            "scikit-learn": {
              "default_value": "",
              "path": "contingency"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "adjusted mutual information score",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.metrics.adjusted_mutual_info_score"
      },
      "type": "Similarity Measure",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "labels_true",
            "kind_of_value": "integer array, shape = [n_samples]",
            "optional": "False",
            "description": "Ground truth class labels to be used as a reference",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_true"
            }
          },
          {
            "name": "labels_pred",
            "kind_of_value": "array, shape = [n_samples]",
            "optional": "False",
            "description": "Cluster labels to evaluate",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_pred"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "normalized mutual information score",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.metrics.normalized_mutual_info_score"
      },
      "type": "Similarity Measure",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "labels_true",
            "kind_of_value": "integer array, shape = [n_samples]",
            "optional": "False",
            "description": "Ground truth class labels to be used as a reference",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_true"
            }
          },
          {
            "name": "labels_pred",
            "kind_of_value": "array, shape = [n_samples]",
            "optional": "False",
            "description": "Cluster labels to evaluate",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_pred"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "homogeneity score",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.metrics.homogeneity_score"
      },
      "type": "Similarity Measure",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "labels_true",
            "kind_of_value": "integer array, shape = [n_samples]",
            "optional": "False",
            "description": "Ground truth class labels to be used as a reference",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_true"
            }
          },
          {
            "name": "labels_pred",
            "kind_of_value": "array, shape = [n_samples]",
            "optional": "False",
            "description": "Cluster labels to evaluate",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_pred"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "completeness score",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.metrics.completeness_score"
      },
      "type": "Similarity Measure",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "labels_true",
            "kind_of_value": "integer array, shape = [n_samples]",
            "optional": "False",
            "description": "Ground truth class labels to be used as a reference",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_true"
            }
          },
          {
            "name": "labels_pred",
            "kind_of_value": "array, shape = [n_samples]",
            "optional": "False",
            "description": "Cluster labels to evaluate",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_pred"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "v-measure score",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.metrics.v_measure_score"
      },
      "type": "Similarity Measure",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "labels_true",
            "kind_of_value": "integer array, shape = [n_samples]",
            "optional": "False",
            "description": "Ground truth class labels to be used as a reference",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_true"
            }
          },
          {
            "name": "labels_pred",
            "kind_of_value": "array, shape = [n_samples]",
            "optional": "False",
            "description": "Cluster labels to evaluate",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_pred"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "homogeneity completeness v-measure score",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.metrics.homogeneity_completeness_v_measure"
      },
      "type": "Similarity Measure",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "labels_true",
            "kind_of_value": "integer array, shape = [n_samples]",
            "optional": "False",
            "description": "Ground truth class labels to be used as a reference",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_true"
            }
          },
          {
            "name": "labels_pred",
            "kind_of_value": "array, shape = [n_samples]",
            "optional": "False",
            "description": "Cluster labels to evaluate",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_pred"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "Fowlkes-Mallows score",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.metrics.fowlkes_mallows_score"
      },
      "type": "Similarity Measure",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "labels_true",
            "kind_of_value": "integer array, shape = [n_samples]",
            "optional": "False",
            "description": "Ground truth class labels to be used as a reference",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_true"
            }
          },
          {
            "name": "labels_pred",
            "kind_of_value": "array, shape = [n_samples]",
            "optional": "False",
            "description": "Cluster labels to evaluate",
            "scikit-learn": {
              "default_value": "",
              "path": "labels_pred"
            }
          },
          {
            "name": "sparse",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Compute contingency matrix internally with sparse matrix.",
            "scikit-learn": {
              "default_value": "False",
              "path": "sparse"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "silhouette coefficient score",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.metrics.silhouette_score"
      },
      "type": "Similarity Measure",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "distance_array",
            "kind_of_value": "array [n_samples_a, n_samples_a] if metric == “precomputed”, or, [n_samples_a, n_features] otherwise",
            "optional": "False",
            "description": "Array of pairwise distances between samples, or a feature array.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "labels",
            "kind_of_value": "array, shape = [n_samples]",
            "optional": "False",
            "description": "Predicted labels for each sample.",
            "scikit-learn": {
              "default_value": "",
              "path": "labels"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The metric to use when calculating distance between instances in a feature array.",
            "scikit-learn": {
              "default_value": "'euclidean'",
              "path": "metric"
            }
          },
          {
            "name": "sample_size",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "The size of the sample to use when computing the Silhouette Coefficient on a random subset of the data. ",
            "scikit-learn": {
              "default_value": "None",
              "path": "sample_size"
            }
          },
          {
            "name": "**kwds",
            "kind_of_value": "optional keyword parameters",
            "optional": "True",
            "description": "Any further parameters are passed directly to the distance function.",
            "scikit-learn": {
              "default_value": "",
              "path": "**kwds"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "Calinski Harabaz score",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.metrics.calinski_harabaz_score"
      },
      "type": "Similarity Measure",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "distance_array",
            "kind_of_value": "array [n_samples_a, n_features]",
            "optional": "False",
            "description": "List of n_features-dimensional data points. Each row corresponds to a single data point.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "labels",
            "kind_of_value": "array, shape = [n_samples]",
            "optional": "False",
            "description": "Predicted labels for each sample.",
            "scikit-learn": {
              "default_value": "",
              "path": "labels"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "spectral co-clustering",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.cluster.bicluster.SpectralCoclustering"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of biclusters to find.",
            "scikit-learn": {
              "default_value": "3",
              "path": "n_clusters"
            }
          },
          {
            "name": "svd_method",
            "kind_of_value": "{'randomized', 'arpack'}",
            "optional": "True",
            "description": "Selects the algorithm for finding singular vectors.",
            "scikit-learn": {
              "default_value": "'randomized'",
              "path": "svd_method"
            }
          },
          {
            "name": "num_svd_vecs",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Number of vectors to use in calculating the SVD.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_svd_vecs"
            }
          },
          {
            "name": "mini_batch",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use mini-batch k-means, which is faster but may get different results.",
            "scikit-learn": {
              "default_value": "False",
              "path": "mini_batch"
            }
          },
          {
            "name": "initialization_method",
            "kind_of_value": "{'k-means++', 'random',  array of shape (n_clusters, n_features)}",
            "optional": "False",
            "description": "Method for initialization of k-means algorithm.",
            "scikit-learn": {
              "default_value": "'k-means++'",
              "path": "init"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "num_initialization",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of time the k-means algorithm will be run with different centroid seeds.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_init"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "spectral biclustering",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.cluster.bicluster.SpectralBiclustering"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of biclusters to find.",
            "scikit-learn": {
              "default_value": "3",
              "path": "n_clusters"
            }
          },
          {
            "name": "method",
            "kind_of_value": "{'scale', 'bistochastic', 'log'}",
            "optional": "True",
            "description": "Method of normalizing and converting singular vectors into biclusters.",
            "scikit-learn": {
              "default_value": "'bistochastic'",
              "path": "method"
            }
          },
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of singular vectors to check.",
            "scikit-learn": {
              "default_value": "6",
              "path": "n_components"
            }
          },
          {
            "name": "num_best",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of best singular vectors to which to project the data for clustering.",
            "scikit-learn": {
              "default_value": "3",
              "path": "n_best"
            }
          },
          {
            "name": "svd_method",
            "kind_of_value": "{'randomized', 'arpack'}",
            "optional": "True",
            "description": "Selects the algorithm for finding singular vectors.",
            "scikit-learn": {
              "default_value": "'randomized'",
              "path": "svd_method"
            }
          },
          {
            "name": "num_svd_vecs",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Number of vectors to use in calculating the SVD.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_svd_vecs"
            }
          },
          {
            "name": "mini_batch",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use mini-batch k-means, which is faster but may get different results.",
            "scikit-learn": {
              "default_value": "False",
              "path": "mini_batch"
            }
          },
          {
            "name": "initialization_method",
            "kind_of_value": "{'k-means++', 'random',  array of shape (n_clusters, n_features)}",
            "optional": "False",
            "description": "Method for initialization of k-means algorithm.",
            "scikit-learn": {
              "default_value": "'k-means++'",
              "path": "init"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "num_initialization",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of time the k-means algorithm will be run with different centroid seeds.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_init"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "",
      "other_names": [],
      "implementation": {
        "scikit-learn": ""
      },
      "type": "",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "",
            "kind_of_value": "",
            "optional": "",
            "description": "",
            "scikit-learn": {
              "default_value": "",
              "path": ""
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "",
            "kind_of_value": "",
            "optional": "",
            "description": "",
            "scikit-learn": {
              "default_value": "",
              "path": ""
            }
          }
        ],
        "execution_parameters": []
      }
    }
  ]
}