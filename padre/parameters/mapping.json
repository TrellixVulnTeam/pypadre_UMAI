{
  "algorithms": [
    {
      "name": "linear regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.base.LinearRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": [
        ]
      }
    },
    {
      "name": "ridge regression",
      "other_names": [
        "Tikhonov regularization",
        "weight decay",
        "Tikhonov–Miller method",
        "Phillips–Twomey method",
        "constrained linear inversion",
        "linear regularization"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.ridge.Ridge"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularisation_strength",
            "kind_of_value": "float, array-like in the shape of the targets",
            "optional": "False",
            "description": "Regularization strength; must be a positive float. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'}",
            "optional": "False",
            "description": "Solver to use in the computational routines: -'auto' chooses the solver automatically based on the type of data. -'svd' uses a Singular Value Decomposition of X to compute the Ridge coefficients. More stable for singular matrices than 'cholesky'. -'cholesky' uses the standard scipy.linalg.solve function to obtain a closed-form solution. -'sparse_cg' uses the conjugate gradient solver as found in scipy.sparse.linalg.cg. As an iterative algorithm, this solver is more appropriate than 'cholesky' for large-scale data (possibility to set tol and max_iter). -'lsqr' uses the dedicated regularized least-squares routine scipy.sparse.linalg.lsqr. It is the fastest but may not be available in old scipy versions. It also uses an iterative procedure. -'sag' uses a Stochastic Average Gradient descent, and 'saga' uses its improved, unbiased version named SAGA. Both methods also use an iterative procedure, and are often faster than other solvers when both n_samples and n_features are large. Note that 'sag' and 'saga' fast convergence is only guaranteed on features with approximately the same scale. You can preprocess the data with a scaler from sklearn.preprocessing.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "solver"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": [
        ]
      }
    },
    {
      "name": "lasso",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.Lasso"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1 term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tolerance, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "positive",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "scikit-learn": {
              "default_value": "False",
              "path": "positive"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "{'cyclic', 'random'}",
            "optional": "False",
            "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default.",
            "scikit-learn": {
              "default_value": "'cyclic'",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "multi-task lasso",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.MultiTaskLasso"
      },
      "type": "Regression",
      "hyper_parameters": [
        {
          "name": "l1_l2_multiplier",
          "kind_of_value": "float",
          "optional": "True",
          "description": "Constant that multiplies the L1/L2 term.",
          "scikit-learn": {
            "default_value": "1.0",
            "path": "alpha"
          }
        },
        {
          "name": "fit_intercept",
          "kind_of_value": "boolean",
          "optional": "False",
          "description": "Whether to calculate the intercept for this model.",
          "scikit-learn": {
            "default_value": "True",
            "path": "fit_intercept"
          }
        },
        {
          "name": "normalize",
          "kind_of_value": "boolean",
          "optional": "True",
          "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
          "scikit-learn": {
            "default_value": "False",
            "path": "normalize"
          }
        },
        {
          "name": "tolerance",
          "kind_of_value": "float",
          "optional": "True",
          "description": "The tolerance for the optimization: if the updates are smaller than tol, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
          "scikit-learn": {
            "default_value": "0.0001",
            "path": "tol"
          }
        },
        {
          "name": "reuse_previous",
          "kind_of_value": "boolean",
          "optional": "True",
          "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
          "scikit-learn": {
            "default_value": "False",
            "path": "warm_start"
          }
        },
        {
          "name": "selection",
          "kind_of_value": "{'random', 'cyclic'}",
          "optional": "False",
          "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default.",
          "scikit-learn": {
            "default_value": "'cyclic'",
            "path": "selection"
          }
        }
      ],
      "optimisation_parameters": [
        {
          "name": "max_iterations",
          "kind_of_value": "integer",
          "optional": "True",
          "description": "Maximum number of iterations.",
          "scikit-learn": {
            "default_value": "None",
            "path": "max_iter"
          }
        }
      ],
      "execution_parameters": [
      ]
    },
    {
      "name": "elastic net",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.ElasticNet"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_l2_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1/L2 term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The ElasticNet mixing parameter, with 0 <= l1_ratio <= 1. For l1_ratio = 0 the penalty is an L2 penalty. For l1_ratio = 1 it is an L1 penalty. For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "l1_ratio"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tol, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "positive",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "scikit-learn": {
              "default_value": "False",
              "path": "positive"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "{'random', 'cyclic'}",
            "optional": "False",
            "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default.",
            "scikit-learn": {
              "default_value": "'cyclic'",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "boolean, array-like",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "scikit-learn": {
              "default_value": "False",
              "path": "precompute"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": [
        ]
      }
    },
    {
      "name": "multi-task elastic net",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.MultiTaskElasticNet"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_l2_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1/L2 term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The ElasticNet mixing parameter, with 0 <= l1_ratio <= 1. For l1_ratio = 0 the penalty is an L2 penalty. For l1_ratio = 1 it is an L1 penalty. For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "l1_ratio"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tol, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "{'random', 'cyclic'}",
            "optional": "False",
            "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default.",
            "scikit-learn": {
              "default_value": "'cyclic'",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": [
        ]
      }
    },
    {
      "name": "least angle regression",
      "other_names": [
        "LARS"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.Lars"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "nonzero_coefficients",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Target number of non-zero coefficients.",
            "scikit-learn": {
              "default_value": "500",
              "path": "n_nonzero_coefs"
            }
          },
          {
            "name": "eps",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems.",
            "scikit-learn": {
              "default_value": "2.2204460492503131e-16",
              "path": "eps"
            }
          },
          {
            "name": "positive_coef",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "scikit-learn": {
              "default_value": "False",
              "path": "positive"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "boolean, array-like",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "scikit-learn": {
              "default_value": "False",
              "path": "precompute"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "lasso least angle regression",
      "other_names": [
        "LassoLars"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.LassoLars"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "penalty_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the penalty term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "eps",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems.",
            "scikit-learn": {
              "default_value": "2.2204460492503131e-16",
              "path": "eps"
            }
          },
          {
            "name": "positive_coef",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "scikit-learn": {
              "default_value": "False",
              "path": "positive"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{True, False, 'auto'}",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "precompute"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "orthogonal matching pursuit model",
      "other_names": [
        "OMP"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.OrthogonalMatchingPursuit"
      },
      "type": "Model Fit Aproximator",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "nonzero_coef",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Target number of non-zero coefficients.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_nonzero_coefs"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Maximum norm of the residual.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "True",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{True, False, 'auto'}",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix  and Xy matrix to speed up calculations. Matrices can also be directly passed to the fit method.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "precompute"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "n-target orthogonal matching pursuit",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.orthogonal_mp"
      },
      "type": "Model Fit Aproximator",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "input_data",
            "kind_of_value": "array, shape (n_samples, n_features)",
            "optional": "False",
            "description": "Input data. Columns are assumed to have unit norm.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "input_targets",
            "kind_of_value": "array, shape (n_samples) or (n_samples, n_targets)",
            "optional": "False",
            "description": "Input targets",
            "scikit-learn": {
              "default_value": "",
              "path": "Y"
            }
          },
          {
            "name": "nonzero_coefficients",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Target number of non-zero coefficients.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_nonzero_coefs"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Maximum norm of the residual.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{True, False, 'auto'}",
            "optional": "False",
            "description": "Whether to perform precomputations.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "precompute"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "bayesian ridge regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.BayesianRidge"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "alpha_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the alpha parameter.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "alpha_1"
            }
          },
          {
            "name": "alpha_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the alpha parameter.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "alpha_2"
            }
          },
          {
            "name": "lambda_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the lambda parameter.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "lambda_1"
            }
          },
          {
            "name": "lambda_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the lambda parameter.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "lambda_2"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "300",
              "path": "n_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "automatic relevance determination regression",
      "other_names": [
        "ARD regrssion"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.ARDRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "alpha_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the alpha parameter.",
            "scikit-learn": {
              "default_value": "1e-06",
              "path": "alpha_1"
            }
          },
          {
            "name": "alpha_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the alpha parameter.",
            "scikit-learn": {
              "default_value": "1e-06",
              "path": "alpha_2"
            }
          },
          {
            "name": "lambda_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the lambda parameter.",
            "scikit-learn": {
              "default_value": "1e-06",
              "path": "lambda_1"
            }
          },
          {
            "name": "lambda_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the lambda parameter.",
            "scikit-learn": {
              "default_value": "1e-06",
              "path": "lambda_2"
            }
          },
          {
            "name": "threshold_lambda",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold for removing (pruning) weights with high precision from the computation. ",
            "scikit-learn": {
              "default_value": "10000.0",
              "path": "threshold_lambda"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "300",
              "path": "n_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "logistic regression",
      "other_names": [
        "logit regression",
        "maximum-entropy classification",
        "MaxEnt",
        "log-linear classifier"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.LogisticRegression"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "penalty_norm",
            "kind_of_value": "{l1, l2}",
            "optional": "False",
            "description": "Used to specify the norm used in the penalization.",
            "scikit-learn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Tolerance for stopping criteria.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "inverse_regularisation_strength",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Specifies if a constant (a.k.a. bias or intercept) should be added to the decision function.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict, 'balanced', None}",
            "optional": "False",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{'newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga'}",
            "optional": "False",
            "description": "Solver to use in the computational routines.",
            "scikit-learn": {
              "default_value": "'liblinear'",
              "path": "solver"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of CPU cores used when parallelizing over classes.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "stochastic gradient descent classifier",
      "other_names": [
        "SGD classifier"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.SGDClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss_function",
            "kind_of_value": "{'hinge', 'log', 'modified_huber', 'squared_hinge', 'perceptron', 'squared_loss', 'huber', 'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'hinge'",
              "path": "loss"
            }
          },
          {
            "name": "regularization_term",
            "kind_of_value": "{'none', 'l2', 'l1', 'elasticnet'}",
            "optional": "False",
            "description": "The penalty (aka regularization term) to be used.",
            "scikit-learn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "regualrisation_multiplier",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Constant that multiplies the regularization term.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The Elastic Net mixing parameter.",
            "scikit-learn": {
              "default_value": "0.15",
              "path": "l1_ratio"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{constant, optimal, invscaling}",
            "optional": "True",
            "description": "where t0 is chosen by a heuristic proposed by Leon Bottou.",
            "scikit-learn": {
              "default_value": "optimal",
              "path": "learning_rate"
            }
          },
          {
            "name": "eta0",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The initial learning rate for the 'constant' or 'invscaling' schedules.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "eta0"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The exponent for inverse scaling learning rate.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": " power_t"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{{class_label: weight}, 'balanced',  None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of CPUs to use to do the OVA (One Versus All, for multi-class problems) computation. -1 means 'all CPUs'.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "stochastic gradient descent regressor",
      "other_names": [
        "SGD regressor"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.SGDRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss_function",
            "kind_of_value": "{'squared_loss', 'huber', 'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'squared_loss'",
              "path": "loss"
            }
          },
          {
            "name": "regularization_term",
            "kind_of_value": "{'none', 'l2', 'l1', 'elasticnet'}",
            "optional": "False",
            "description": "The penalty (aka regularization term) to be used.",
            "scikit-learn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "regualrisation_multiplier",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Constant that multiplies the regularization term.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The Elastic Net mixing parameter.",
            "scikit-learn": {
              "default_value": "0.15",
              "path": "l1_ratio"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{'constant', 'optimal', 'invscaling'}",
            "optional": "True",
            "description": "where t0 is chosen by a heuristic proposed by Leon Bottou.",
            "scikit-learn": {
              "default_value": "'invscaling'",
              "path": "learning_rate"
            }
          },
          {
            "name": "eta0",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The initial learning rate for the 'constant' or 'invscaling' schedules.",
            "scikit-learn": {
              "default_value": "0.01",
              "path": "eta0"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The exponent for inverse scaling learning rate.",
            "scikit-learn": {
              "default_value": "0.25",
              "path": " power_t"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "perceptron",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.Perceptron"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularization_term",
            "kind_of_value": "{none, 'l2', 'l1', 'elasticnet'}",
            "optional": "False",
            "description": "The penalty (aka regularization term) to be used.",
            "scikit-learn": {
              "default_value": "None",
              "path": "penalty"
            }
          },
          {
            "name": "regularisation_multiplier",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Constant that multiplies the regularization term.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "eta0",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The initial learning rate for the 'constant' or 'invscaling' schedules.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "eta0"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{{class_label: weight}, 'balanced',  None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          },
          {
            "name": "epochs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of passes over the training data (aka epochs).",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_iter"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "passive aggressive classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.PassiveAggressiveClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regualrisation",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Maximum step size (regularization).",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'hinge', 'squared_hinge'}",
            "optional": "True",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'hinge'",
              "path": "loss"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict,'balanced', None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "epochs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of passes over the training data (aka epochs).",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of of CPUs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "passive aggressive regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.PassiveAggressiveRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regualrisation",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Maximum step size (regularization).",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "True",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'epsilon_insensitive'",
              "path": "loss"
            }
          },
          {
            "name": "update_threshold",
            "kind_of_value": "float",
            "optional": "False",
            "description": "If the difference between the current prediction and the correct label is below this threshold, the model is not updated.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "epsilon"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "epochs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of passes over the training data (aka epochs).",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "random sample consensus regressor",
      "other_names": [
        "RANSAC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.RANSACRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "base_estimator.",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "min_samples",
            "kind_of_value": "[int (>= 1), float ([0, 1])}",
            "optional": "True",
            "description": "Minimum number of samples chosen randomly from original data.",
            "scikit-learn": {
              "default_value": "None",
              "path": "min_samples"
            }
          },
          {
            "name": "residual_threshold",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Maximum residual for a data sample to be classified as an inlier. By default the threshold is chosen as the MAD (median absolute deviation) of the target values y.",
            "scikit-learn": {
              "default_value": "None",
              "path": "residual_threshold"
            }
          },
          {
            "name": "loss",
            "kind_of_value": "{'absolute_loss', 'squared_loss'}",
            "optional": "True",
            "description": "If loss is a callable, then it should be a function that takes two arrays as inputs, the true and predicted value and returns a 1-D array with the i-th value of the array corresponding to the loss on X[i].",
            "scikit-learn": {
              "default_value": "absolute_loss",
              "path": "loss"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "iterations_random_sampling",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations for random sample selection.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_trials"
            }
          },
          {
            "name": "max_skips",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations that can be skipped due to finding zero inliers or invalid data.",
            "scikit-learn": {
              "default_value": "inf",
              "path": "max_skips"
            }
          },
          {
            "name": "stop_n_inliers",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Stop iteration if at least this number of inliers are found.",
            "scikit-learn": {
              "default_value": "inf",
              "path": "stop_n_inliers"
            }
          },
          {
            "name": "stop_score",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Stop iteration if score is greater equal than this threshold.",
            "scikit-learn": {
              "default_value": "inf",
              "path": "stop_score"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "theil-sen estimator",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.TheilSenRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "max_subpopulation",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "",
            "scikit-learn": {
              "default_value": "10000",
              "path": "max_subpopulation"
            }
          },
          {
            "name": "num_subsamples",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of samples to calculate the parameters.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_subsamples"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance when calculating spatial median.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations for the calculation of spatial median.",
            "scikit-learn": {
              "default_value": "300",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of CPUs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "huber regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.HuberRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "number_of_outliers",
            "kind_of_value": "float > 1.0",
            "optional": "False",
            "description": "The parameter controls the number of samples that should be classified as outliers. The smaller the parameter, the more robust it is to outliers.",
            "scikit-learn": {
              "default_value": "1.35",
              "path": "epsilon"
            }
          },
          {
            "name": "regularization_parameter",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Regularization parameter.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "1e-05",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations that scipy.optimize.fmin_l_bfgs_b should run for.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "linear discriminant analysis",
      "other_names": [
        "LDA"
      ],
      "implementation": {
        "scikit-learn": "sklearn.discriminant_analysis.LinearDiscriminantAnalysis"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimation_algorithm",
            "kind_of_value": "{'svd', 'lsqr', 'eigen'}",
            "optional": "True",
            "description": "Possible values: singular value decomposition (svd), least squares solution (lsqr), eigenvalue decomposition (eigen)",
            "scikit-learn": {
              "default_value": "'svd'",
              "path": "solver"
            }
          },
          {
            "name": "shrinkage",
            "kind_of_value": "{None, 'auto', float between 0 and 1}",
            "optional": "True",
            "description": "Shrinkage is a tool to improve estimation of covariance matrices in situations where the number of training samples is small compared to the number of features. Possible values: no shrinkage (None), automatic shrinkage using the Ledoit-Wolf lemma (auto), fixed shrinkage parameter(float between 0 and 1)",
            "scikit-learn": {
              "default_value": "None",
              "path": "shrinkage"
            }
          },
          {
            "name": "n_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of components (< n_classes - 1) for dimensionality reduction.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold used for rank estimation in SVD solver.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "quadratic discriminant analysis",
      "other_names": [
        "QDA"
      ],
      "implementation": {
        "scikit-learn": "sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularisation_parameter",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Regularizes the covariance estimate.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "reg_param"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold used for rank estimation.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "kernel ridge regression",
      "other_names": [
        "KRR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.kernel_ridge.KernelRidge"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularisation_strength",
            "kind_of_value": "float, array-like in the shape of the targets",
            "optional": "False",
            "description": "Regularization strength; must be a positive float. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization. Lambda corresponds to C^-1 in other linear models such as LogisticRegression or LinearSVC.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'cosine', 'gaussian', 'tophat', 'epanechnikov', 'exponential', 'precomputed', callable}",
            "optional": "False",
            "description": "Kernel mapping used internally. A callable should accept two arguments and the keyword arguments passed to this object as kernel_params, and should return a floating point number.",
            "scikit-learn": {
              "default_value": "'linear'",
              "path": "kernel"
            }
          },
          {
            "name": "gamma",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Gamma parameter for the RBF, laplacian, polynomial, exponential chi2 and sigmoid kernels. Interpretation depends on kernels.",
            "scikit-learn": {
              "default_value": "None",
              "path": "gamma"
            }
          },
          {
            "name": "kernel_degree",
            "kind_of_value": "float",
            "optional": "float",
            "description": "Degree of the polynomial kernel.",
            "scikit-learn": {
              "default_value": "3.0",
              "path": "degree"
            }
          },
          {
            "name": "zero_coefficient",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Zero coefficient for polynomial and sigmoid kernels.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "coef0"
            }
          },
          {
            "name": "kernel_parameters",
            "kind_of_value": "mapping of string to any",
            "optional": "True",
            "description": "Additional parameters (keyword arguments) for kernel function passed as callable object.",
            "scikit-learn": {
              "default_value": "None",
              "path": "kernel_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "c-support vector classification.",
      "other_names": [
        "SVC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.SVC"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "{float, 'auto'}",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dictionary with weights for all calsses, 'balanced', None}",
            "optional": "True",
            "description": "Weights the classes. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "nu-support vector classification",
      "other_names": [
        "nuSVC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.NuSVC"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "nu",
            "kind_of_value": "float (0, 1]",
            "optional": "True",
            "description": "An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1].",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "nu"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float or 'auto'",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dictionary with weights for all calsses, 'balanced', None}",
            "optional": "True",
            "description": "Weights the classes. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "linear-support vector classification",
      "other_names": [
        "linear SVC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.LinearSVC"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "penalty_norm",
            "kind_of_value": "{'l1', 'l2'}",
            "optional": "False",
            "description": "Specifies the norm used in the penalization.",
            "scikit-learn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'hinge', 'squared_hinge'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'squared_hinge'",
              "path": "loss"
            }
          },
          {
            "name": "dual",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Select the algorithm to either solve the dual or primal optimization problem.",
            "scikit-learn": {
              "default_value": "True",
              "path": "dual"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criteria.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "multi_class_strategy",
            "kind_of_value": "{'ovr', 'crammer_singer'}",
            "optional": "False",
            "description": "Determines the multi-class strategy if y contains more than two classes.",
            "scikit-learn": {
              "default_value": "'ovr'",
              "path": "multi_class"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dictionary with weights for all calsses, 'balanced', None}",
            "optional": "True",
            "description": "Weights the classes. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations to be run.",
            "scikit-learn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "epsilon-support vector regression",
      "other_names": [
        "SVR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.SVR"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Epsilon in the epsilon-SVR model. It specifies the epsilon-tube within which no penalty is associated in the training loss function with points predicted within a distance epsilon from the actual value.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "epsilon"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float or 'auto'",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "nu-support vector regression",
      "other_names": [
        "nuSVR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.NuSVR"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "nu",
            "kind_of_value": "float (0, 1]",
            "optional": "True",
            "description": "An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1].",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "nu"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float or 'auto'",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "linear-support vector regression",
      "other_names": [
        "linearSVR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.LinearSVR"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'epsilon_insensitive'",
              "path": "loss"
            }
          },
          {
            "name": "epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Epsilon parameter in the epsilon-insensitive loss function. Note that the value of this parameter depends on the scale of the target variable y.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "epsilon"
            }
          },
          {
            "name": "dual",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Select the algorithm to either solve the dual or primal optimization problem.",
            "scikit-learn": {
              "default_value": "True",
              "path": "dual"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations to be run.",
            "scikit-learn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "one-class support vector machine",
      "other_names": [
        "one-calss SVM"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.OneClassSVM"
      },
      "type": "Outlier Detection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "nu",
            "kind_of_value": "float (0, 1]",
            "optional": "True",
            "description": "An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1].",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "nu"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "{float, 'auto'}",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "nearest neighbours",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.NearestNeighbors"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use by default for kneighbors queries.",
            "scikit-learn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "radius",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Range of parameter space to use by default for radius_neighbors queries.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "radius"
            }
          },
          {
            "name": "algorithm",
            "kind_of_value": "{'ball_tree', 'kd_tree', 'brute', 'auto'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "Metric to use for distance computation.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "k-d tree",
      "other_names": [
        "KDTree",
        "k-dimensional tree"
      ],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.KDTree"
      },
      "type": "Search Tree",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "samples_feature",
            "kind_of_value": "array, shape: [n_samples, n_features]",
            "optional": "False",
            "description": "n_samples is the number of points in the data set, and n_features is the dimension of the parameter space.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'p', 'l1', 'chebyshev', 'manhattan', 'minkowski', 'cityblock', 'l2', 'euclidean', 'infinity'}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "leaf_size",
            "kind_of_value": "positive integer",
            "optional": "False",
            "description": "Number of points at which to switch to brute-force. Changing leaf_size will not affect the results of a query, but can significantly impact the speed of a query and the memory required to store the constructed tree.",
            "scikit-learn": {
              "default_value": "40",
              "path": "leaf_size"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "ball tree",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.BallTree"
      },
      "type": "Search Tree",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "samples_feature",
            "kind_of_value": "array, shape: [n_samples, n_features]",
            "optional": "False",
            "description": "n_samples is the number of points in the data set, and n_features is the dimension of the parameter space.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'seuclidean', 'hamming', 'dice', 'jaccard', 'matching', 'russellrao',  'euclidean', 'kulsinski', 'wminkowski', 'chebyshev', 'mahalanobis', 'sokalmichener', 'rogerstanimoto', 'infinity', 'p', 'canberra',  'haversine', 'sokalsneath', 'l1', 'minkowski', 'pyfunc', 'l2', 'cityblock', 'braycurtis', 'manhattan'}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "leaf_size",
            "kind_of_value": "positive integer",
            "optional": "False",
            "description": "Number of points at which to switch to brute-force. Changing leaf_size will not affect the results of a query, but can significantly impact the speed of a query and the memory required to store the constructed tree.",
            "scikit-learn": {
              "default_value": "40",
              "path": "leaf_size"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "radius neighbors classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.RadiusNeighborsClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "radius",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Range of parameter space to use.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "radius"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{'uniform', 'distance', callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "scikit-learn": {
              "default_value": "'uniform'",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "outlier_label",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Label, which is given for outlier samples (samples with no neighbors on given radius). If set to None, ValueError is raised, when outlier is detected.",
            "scikit-learn": {
              "default_value": "None",
              "path": "outlier_label"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "k-nn classifier",
      "other_names": [
        " k-nearest neighbors calssifier"
      ],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.KNeighborsClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_neighbors",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use.",
            "scikit-learn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{'uniform', 'distance', callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "scikit-learn": {
              "default_value": "'uniform'",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "k-nn regressor",
      "other_names": [
        " k-nearest neighbors regressor"
      ],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.KNeighborsRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_neighbors",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use.",
            "scikit-learn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{'uniform', 'distance', callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "scikit-learn": {
              "default_value": "'uniform'",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "radius neighbors regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.RadiusNeighborsRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "radius",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Range of parameter space to use.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "radius"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{'uniform', 'distance', callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "scikit-learn": {
              "default_value": "'uniform'",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "nearest centroid classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.NearestCentroid"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'}",
            "optional": "False",
            "description": "The metric to use when calculating distance between instances in a feature array.",
            "scikit-learn": {
              "default_value": "'euclidean''",
              "path": "metric"
            }
          },
          {
            "name": "shrink_threshold",
            "kind_of_value": "float or None",
            "optional": "True",
            "description": "Threshold for shrinking centroids to remove features.",
            "scikit-learn": {
              "default_value": "None",
              "path": "shrink_threshold"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "gaussian process regression",
      "other_names": [
        "GPR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.gaussian_process.GaussianProcessRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "kernel",
            "kind_of_value": "kernel object",
            "optional": "False",
            "description": "The kernel specifying the covariance function of the GP.",
            "scikit-learn": {
              "default_value": "None",
              "path": "kernel"
            }
          },
          {
            "name": "kernel_optimizer",
            "kind_of_value": "{'fmin_l_bfgs_b', externally defined optimizer passed as a callable }",
            "optional": "True",
            "description": "Optimizer to optimize the kernel parameters.",
            "scikit-learn": {
              "default_value": "'fmin_l_bfgs_b'",
              "path": "optimizer"
            }
          },
          {
            "name": "n_restarts_optimizer",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of restarts of the optimizer for finding the kernel's parameters which maximize the log-marginal likelihood. The first run of the optimizer is performed from the kernel's initial parameters, the remaining ones (if any) from thetas sampled log-uniform randomly from the space of allowed theta-values.",
            "scikit-learn": {
              "default_value": "0",
              "path": "n_restarts_optimizer"
            }
          },
          {
            "name": "normalize_y",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether the target values y are normalized, i.e., the mean of the observed target values become zero. This parameter should be set to True if the target values' mean is expected to differ considerable from zero. When enabled, the normalization effectively modifies the GP's prior based on the data, which contradicts the likelihood principle.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize_y"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "gaussian process classification",
      "other_names": [
        "GPC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.gaussian_process.GaussianProcessClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "kernel",
            "kind_of_value": "kernel object",
            "optional": "False",
            "description": "The kernel specifying the covariance function of the GP.",
            "scikit-learn": {
              "default_value": "None",
              "path": "kernel"
            }
          },
          {
            "name": "kernel_optimizer",
            "kind_of_value": "{'fmin_l_bfgs_b', externally defined optimizer passed as a callable }",
            "optional": "True",
            "description": "Optimizer to optimize the kernel parameters.",
            "scikit-learn": {
              "default_value": "'fmin_l_bfgs_b'",
              "path": "optimizer"
            }
          },
          {
            "name": "n_restarts_optimizer",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of restarts of the optimizer for finding the kernel's parameters which maximize the log-marginal likelihood. The first run of the optimizer is performed from the kernel's initial parameters, the remaining ones (if any) from thetas sampled log-uniform randomly from the space of allowed theta-values.",
            "scikit-learn": {
              "default_value": "0",
              "path": "n_restarts_optimizer"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, the solution of the last Newton iteration on the Laplace approximation of the posterior mode is used as initialization for the next call, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "multi_class",
            "kind_of_value": "{'one_vs_rest', 'one_vs_one'}",
            "optional": "False",
            "description": "Specifies how multi-class classification problems are handled.",
            "scikit-learn": {
              "default_value": "'one_vs_rest'",
              "path": "multi_class"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "partial least squares regression",
      "other_names": [
        "PLS Regession"
      ],
      "implementation": {
        "scikit-learn": "sklearn.cross_decomposition.PLSRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of components to keep.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "scale",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to scale the data.",
            "scikit-learn": {
              "default_value": "True",
              "path": "scale"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "positive float",
            "optional": "False",
            "description": "Tolerance used in the iterative algorithm.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations of the NIPALS inner loop.",
            "scikit-learn": {
              "default_value": "500",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "2 blocks canonical partial least squares",
      "other_names": [
        "PLS Canonical"
      ],
      "implementation": {
        "scikit-learn": "sklearn.cross_decomposition.PLSCanonical"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of components to keep.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "scale",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to scale the data.",
            "scikit-learn": {
              "default_value": "True",
              "path": "scale"
            }
          },
          {
            "name": "weight_algorithm",
            "kind_of_value": "{'nipals', 'svd'}",
            "optional": "False",
            "description": "The algorithm used to estimate the weights.",
            "scikit-learn": {
              "default_value": "'nipals'",
              "path": "algorithm"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "positive float",
            "optional": "False",
            "description": "Tolerance used in the iterative algorithm.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations of the NIPALS inner loop.",
            "scikit-learn": {
              "default_value": "500",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "partial least squares singular value decomposition",
      "other_names": [
        "PLSSVD"
      ],
      "implementation": {
        "scikit-learn": "sklearn.cross_decomposition.PLSSVD"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of components to keep.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "scale",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to scale the data.",
            "scikit-learn": {
              "default_value": "True",
              "path": "scale"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "canonical correlation analysis",
      "other_names": [
        "CCA"
      ],
      "implementation": {
        "scikit-learn": "sklearn.cross_decomposition.CCA"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of components to keep.",
            "scikit-learn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "scale",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to scale the data.",
            "scikit-learn": {
              "default_value": "True",
              "path": "scale"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "positive float",
            "optional": "False",
            "description": "Tolerance used in the iterative algorithm.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations of the NIPALS inner loop.",
            "scikit-learn": {
              "default_value": "500",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "gaussian naive bayes",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.naive_bayes.GaussianNB"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "class_priors",
            "kind_of_value": "array-like, shape (n_classes)",
            "optional": "False",
            "description": "Prior probabilities of the classes. If specified the priors are not adjusted according to the data.",
            "scikit-learn": {
              "default_value": "None",
              "path": "priors"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "multinomial naive bayes classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.naive_bayes.MultinomialNB"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "smoothing parameter",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Additive (Laplace/Lidstone) smoothing parameter.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "learn_prior_probabilities",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to learn class prior probabilities or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_prior"
            }
          },
          {
            "name": "class_priors",
            "kind_of_value": "array-like, shape (n_classes)",
            "optional": "False",
            "description": "Prior probabilities of the classes. If specified the priors are not adjusted according to the data.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_prior"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "bernoulli naive bayes classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.naive_bayes.BernoulliNB"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "smoothing parameter",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Additive (Laplace/Lidstone) smoothing parameter.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "binarizeing_threshold",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold for binarizing (mapping to booleans) of sample features.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "binarize"
            }
          },
          {
            "name": "learn_prior_probabilities",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to learn class prior probabilities or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_prior"
            }
          },
          {
            "name": "class_priors",
            "kind_of_value": "array-like, shape (n_classes)",
            "optional": "False",
            "description": "Prior probabilities of the classes. If specified the priors are not adjusted according to the data.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_prior"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "",
            "kind_of_value": "",
            "optional": "",
            "description": "",
            "scikit-learn": {
              "default_value": "",
              "path": ""
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "decision tree classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.tree.DecisionTreeClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "split_quality",
            "kind_of_value": "{'gini', 'entropy'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'gini'",
              "path": "criterion"
            }
          },
          {
            "name": "splitting_strategy",
            "kind_of_value": "{'best', 'random'}",
            "optional": "True",
            "description": "The strategy used to choose the split at each node.",
            "scikit-learn": {
              "default_value": "'best'",
              "path": "splitter"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_features"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict, list of dicts, 'balanced', None}",
            "optional": "False",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "decision tree regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.tree.DecisionTreeRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'friedman_mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'mse'",
              "path": "criterion"
            }
          },
          {
            "name": "splitting_strategy",
            "kind_of_value": "{'best', 'random'}",
            "optional": "True",
            "description": "The strategy used to choose the split at each node.",
            "scikit-learn": {
              "default_value": "'best'",
              "path": "splitter"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_features"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "presort",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to presort the data to speed up the finding of best splits in fitting.",
            "scikit-learn": {
              "default_value": "False",
              "path": "presort"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "extra-trees regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.ExtraTreesRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'mse'",
              "path": "criterion"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "max_features"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "scikit-learn": {
              "default_value": "False",
              "path": "bootstrap"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the R^2 on unseen data.",
            "scikit-learn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "extra-trees classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.ExtraTreesClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'gini', 'entropy'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'gini'",
              "path": "criterion"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "max_features"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "scikit-learn": {
              "default_value": "False",
              "path": "bootstrap"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the generalization accuracy.",
            "scikit-learn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict, 'balanced', 'balanced_subsample', None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "random forest regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.RandomForestRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'mse'",
              "path": "criterion"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "max_features"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "scikit-learn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use out-of-bag samples to estimate the R^2 on unseen data.",
            "scikit-learn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "random forest classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.RandomForestClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'gini', 'entropy'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'gini'",
              "path": "criterion"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "max_features"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "scikit-learn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the generalization accuracy.",
            "scikit-learn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict, 'balanced', None}",
            "optional": "False",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "bagging classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.BaggingClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "The base estimator to fit on random subsets of the dataset.",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_samples",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of samples to draw from X to train each base estimator.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "max_samples"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of features to draw from X to train each base estimator.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "max_features"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether samples are drawn with replacement.",
            "scikit-learn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "bootstrap_features",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether features are drawn with replacement.",
            "scikit-learn": {
              "default_value": "False",
              "path": "bootstrap_features"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the generalization error.",
            "scikit-learn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new ensemble.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "bagging regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.BaggingRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "The base estimator to fit on random subsets of the dataset.",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_samples",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of samples to draw from X to train each base estimator.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "max_samples"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of features to draw from X to train each base estimator.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "max_features"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether samples are drawn with replacement.",
            "scikit-learn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "bootstrap_features",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether features are drawn with replacement.",
            "scikit-learn": {
              "default_value": "False",
              "path": "bootstrap_features"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the generalization error.",
            "scikit-learn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new ensemble.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "vating classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.VotingClassifier"
      },
      "type": "Classifcation",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimators",
            "kind_of_value": "string, estimator tuple{('lr', clf1), ('rf', clf2), ('gnb', clf3), ('dt', clf1), ('knn', clf2), ('svc', clf3)}",
            "optional": "False",
            "description": "Used estimators.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimators"
            }
          },
          {
            "name": "voting",
            "kind_of_value": "{'hard', 'soft'}",
            "optional": "False",
            "description": "If 'hard', uses predicted class labels for majority rule voting. Else if 'soft', predicts the class label based on the argmax of the sums of the predicted probabilities, which is recommended for an ensemble of well-calibrated classifiers.",
            "scikit-learn": {
              "default_value": "'hard'",
              "path": "voting"
            }
          },
          {
            "name": "weights",
            "kind_of_value": "array-like, shape = [n_classifiers] integer, float, None",
            "optional": "True",
            "description": "Sequence of weights (float or int) to weight the occurrences of predicted class labels (hard voting) or class probabilities before averaging (soft voting). Uses uniform weights if None.",
            "scikit-learn": {
              "default_value": "None",
              "path": "weights"
            }
          },
          {
            "name": "flatten_transform",
            "kind_of_value": "boolean, None",
            "optional": "True",
            "description": "Affects shape of transform output only when voting='soft'.",
            "scikit-learn": {
              "default_value": "None",
              "path": "flatten_transform"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "gradient boosting for regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.GradientBoostingRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss",
            "kind_of_value": "{'ls', 'lad', 'huber', 'quantile'}",
            "optional": "True",
            "description": "Loss function to be optimized.",
            "scikit-learn": {
              "default_value": "'ls'",
              "path": "loss"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "learning rate shrinks the contribution of each tree by learning_rate.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "learning_rate"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of boosting stages to perform. Gradient boosting is fairly robust to over-fitting so a large number usually results in better performance.",
            "scikit-learn": {
              "default_value": "100",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum depth of the individual regression estimators. The maximum depth limits the number of nodes in the tree. Tune this parameter for best performance; the best value depends on the interaction of the input variables.",
            "scikit-learn": {
              "default_value": "3",
              "path": "max_depth"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'friedman_mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'friedman_mse'",
              "path": "criterion"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "frac_subsample",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The fraction of samples to be used for fitting the individual base learners.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "subsample"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_features"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "integer, None",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "alpha_quantile",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The alpha-quantile of the huber loss function and the quantile loss function. ",
            "scikit-learn": {
              "default_value": "0.9",
              "path": "alpha"
            }
          },
          {
            "name": "init_estimator",
            "kind_of_value": "BaseEstimator, None",
            "optional": "True",
            "description": "An estimator object that is used to compute the initial predictions.",
            "scikit-learn": {
              "default_value": "None",
              "path": "init"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "presort",
            "kind_of_value": "{boolean, 'auto'}",
            "optional": "True",
            "description": "Whether to presort the data to speed up the finding of best splits in fitting.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "presort"
            }
          }
        ],
        "optimisation_parameters": [
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "gradient boosting for classification",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.GradientBoostingClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss",
            "kind_of_value": "{'deviance', 'exponential'}",
            "optional": "True",
            "description": "Loss function to be optimized.",
            "scikit-learn": {
              "default_value": "'deviance'",
              "path": "loss"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "learning rate shrinks the contribution of each tree by learning_rate.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "learning_rate"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of boosting stages to perform. Gradient boosting is fairly robust to over-fitting so a large number usually results in better performance.",
            "scikit-learn": {
              "default_value": "100",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum depth of the individual regression estimators. The maximum depth limits the number of nodes in the tree. Tune this parameter for best performance; the best value depends on the interaction of the input variables.",
            "scikit-learn": {
              "default_value": "3",
              "path": "max_depth"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'friedman_mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "scikit-learn": {
              "default_value": "'friedman_mse'",
              "path": "criterion"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "frac_subsample",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The fraction of samples to be used for fitting the individual base learners.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "subsample"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_features"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "integer, None",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "init_estimator",
            "kind_of_value": "BaseEstimator, None",
            "optional": "True",
            "description": "An estimator object that is used to compute the initial predictions.",
            "scikit-learn": {
              "default_value": "None",
              "path": "init"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "presort",
            "kind_of_value": "{boolean, 'auto'}",
            "optional": "True",
            "description": "Whether to presort the data to speed up the finding of best splits in fitting.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "presort"
            }
          }
        ],
        "optimisation_parameters": [
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "AdaBoost regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.AdaBoostRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "base_estimator.",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of estimators at which boosting is terminated. In case of perfect fit, the learning procedure is stopped early.",
            "scikit-learn": {
              "default_value": "50",
              "path": "n_estimators"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Learning rate shrinks the contribution of each regressor by learning_rate.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "learning_rate"
            }
          },
          {
            "name": "loss",
            "kind_of_value": "{'linear', 'square', 'exponential'}",
            "optional": "True",
            "description": "Loss function to be optimized.",
            "scikit-learn": {
              "default_value": "'linear'",
              "path": "loss"
            }
          }
        ],
        "optimisation_parameters": [
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "AdaBoost classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.AdaBoostClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "base_estimator.",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of estimators at which boosting is terminated. In case of perfect fit, the learning procedure is stopped early.",
            "scikit-learn": {
              "default_value": "50",
              "path": "n_estimators"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Learning rate shrinks the contribution of each regressor by learning_rate.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "learning_rate"
            }
          },
          {
            "name": "boosting_algorithm",
            "kind_of_value": " {'SAMME', 'SAMME.R'}",
            "optional": "True",
            "description": "If ‘SAMME.R’ then use the SAMME.R real boosting algorithm. base_estimator must support calculation of class probabilities. If ‘SAMME’ then use the SAMME discrete boosting algorithm. The SAMME.R algorithm typically converges faster than SAMME, achieving a lower test error with fewer boosting iterations.",
            "scikit-learn": {
              "default_value": "'SAMME.R'",
              "path": "algorithm"
            }
          }
        ],
        "optimisation_parameters": [
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "random trees ensemble",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.ensemble.RandomTreesEmbedding"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "scikit-learn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "scikit-learn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "scikit-learn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "sparse_output",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether or not to return a sparse CSR matrix, as default behavior, or to return a dense array compatible with dense pipeline operators.",
            "scikit-learn": {
              "default_value": "True",
              "path": "sparse_output"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "classifier chain",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.multioutput.ClassifierChain"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "estimator",
            "optional": "False",
            "description": "The base estimator from which the classifier chain is built.",
            "scikit-learn": {
              "default_value": "",
              "path": "base_estimator"
            }
          },
          {
            "name": "prediction_order",
            "kind_of_value": "{array-like, shape=[n_outputs], 'random', None}",
            "optional": "True",
            "description": "Order in which the chain makes predictions about the columns in the label matrix Y.",
            "scikit-learn": {
              "default_value": "None",
              "path": "order"
            }
          },
          {
            "name": "cross-validation",
            "kind_of_value": "{integer, object (cross-validation generator),  iterable yielding train, test splits, None",
            "optional": "True",
            "description": "Determines whether to use cross validated predictions or true labels for the results of previous estimators in the chain.",
            "scikit-learn": {
              "default_value": "None",
              "path": "cv"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "multi target regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.multioutput.MultiOutputRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "An estimator object implementing fit and predict.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "multi label binarizer",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.preprocessing.MultiLabelBinarizer"
      },
      "type": "Transformation",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "classes",
            "kind_of_value": "{array-like of shape [n_classes], None}",
            "optional": "True",
            "description": "Indicates an ordering for the class labels",
            "scikit-learn": {
              "default_value": "None",
              "path": "classes"
            }
          },
          {
            "name": "sparse_output",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Set to true if output binary array is desired in CSR sparse format",
            "scikit-learn": {
              "default_value": "Flase",
              "path": "sparse_output"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "output code classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.multiclass.OutputCodeClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "An estimator object implementing fit and either predict or decision.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          },
          {
            "name": "code_size",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Percentage of the number of classes to be used to create the code book. A number between 0 and 1 will require fewer classifiers than one-vs-the-rest. A number greater than 1 will require more classifiers than one-vs-the-rest.",
            "scikit-learn": {
              "default_value": "1.5",
              "path": "code_size"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "one vs one classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.multiclass.OneVsOneClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "An estimator object implementing fit and either predict or decision.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          }
        ],
        "optimisation_parameters": [
         {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "one vs rest classifier",
      "other_names": ["one vs all classifier"],
      "implementation": {
        "scikit-learn": "sklearn.multiclass.OneVsRestClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "An estimator object implementing fit and either predict or decision.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          }
        ],
        "optimisation_parameters": [
         {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "select from model",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.SelectFromModel"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "The base estimator from which the transformer is built.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          },
          {
            "name": "threshold",
            "kind_of_value": "{'median', 'mean', float, None}",
            "optional": "True",
            "description": "The threshold value to use for feature selection.",
            "scikit-learn": {
              "default_value": "None",
              "path": "threshold"
            }
          },
          {
            "name": "prefit_model",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether a prefit model is expected to be passed into the constructor directly or not.",
            "scikit-learn": {
              "default_value": "False",
              "path": "prefit"
            }
          },
          {
            "name": "norm_order",
            "kind_of_value": "non-zero integer",
            "optional": "False",
            "description": "Order of the norm used to filter the vectors of coefficients below threshold in the case where the coef_ attribute of the estimator is of dimension 2.",
            "scikit-learn": {
              "default_value": "1",
              "path": "norm_order"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "recursive feature elimination with cross-validation",
      "other_names": ["RFECV"],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.RFECV"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "The base estimator from which the transformer is built.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          },
          {
            "name": "step",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "If greater than or equal to 1, then step corresponds to the (integer) number of features to remove at each iteration. If within (0.0, 1.0), then step corresponds to the percentage (rounded down) of features to remove at each iteration.",
            "scikit-learn": {
              "default_value": "1",
              "path": "step"
            }
          },
          {
            "name": "cross-validation",
            "kind_of_value": "{integer, object (cross-validation generator),  iterable yielding train, test splits, None",
            "optional": "True",
            "description": "Determines whether to use cross validated predictions or true labels for the results of previous estimators in the chain.",
            "scikit-learn": {
              "default_value": "None",
              "path": "cv"
            }
          },
          {
            "name": "scoring",
            "kind_of_value": "{callable, None, 'accuracy', 'average_precision', 'f1', 'f1_micro', 'f1_macro', 'f1_weighted', 'f1_samples', 'neg_log_loss', 'precision', 'recall', 'roc_auc', 'adjusted_mutual_info_score', 'adjusted_rand_score', 'completeness_score', 'fowlkes_mallows_score', 'homogeneity_score', 'mutual_info_score', 'normalized_mutual_info_score', 'v_measure_score', 'explained_variance', 'neg_mean_absolute_error', '‘neg_mean_squared_error', 'neg_mean_squared_log_error', 'neg_median_absolute_error', 'r2'}",
            "optional": "True",
            "description": "Scoring parameter that is applied to the evaluated estimator.",
            "scikit-learn": {
              "default_value": "None",
              "path": "scoring"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Controls verbosity of output.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "recursive feature elimination",
      "other_names": ["RFE"],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.RFE"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "The base estimator from which the transformer is built.",
            "scikit-learn": {
              "default_value": "",
              "path": "estimator"
            }
          },
          {
            "name": "n_features_to_select",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "The number of features to select. If None, half of the features are selected.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_features_to_select"
            }
          },
          {
            "name": "step",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "If greater than or equal to 1, then step corresponds to the (integer) number of features to remove at each iteration. If within (0.0, 1.0), then step corresponds to the percentage (rounded down) of features to remove at each iteration.",
            "scikit-learn": {
              "default_value": "1",
              "path": "step"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Controls verbosity of output.",
            "scikit-learn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "mutual information classification",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.mutual_info_classif"
      },
      "type": "Scoring Function",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "feature_matrix",
            "kind_of_value": " array_like or sparse matrix, shape (n_samples, n_features)",
            "optional": "False",
            "description": "Feature matrix.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "target_vector",
            "kind_of_value": "array_like, shape (n_samples)",
            "optional": "False",
            "description": "Target vector.",
            "scikit-learn": {
              "default_value": "",
              "path": "y"
            }
          },
          {
            "name": "discrete_features",
            "kind_of_value": "{'auto', bool, array_like}",
            "optional": "False",
            "description": "If bool, then determines whether to consider all features discrete or continuous. If array, then it should be either a boolean mask with shape (n_features,) or array with indices of discrete features. If ‘auto’, it is assigned to False for dense X and to True for sparse X.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "discrete_features"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use for MI estimation for continuous variables.",
            "scikit-learn": {
              "default_value": "3",
              "path": "n_neighbors"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "mutual information regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.mutual_info_regression"
      },
      "type": "Scoring Function",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "feature_matrix",
            "kind_of_value": " array_like or sparse matrix, shape (n_samples, n_features)",
            "optional": "False",
            "description": "Feature matrix.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "target_vector",
            "kind_of_value": "array_like, shape (n_samples)",
            "optional": "False",
            "description": "Target vector.",
            "scikit-learn": {
              "default_value": "",
              "path": "y"
            }
          },
          {
            "name": "discrete_features",
            "kind_of_value": "{'auto', bool, array_like}",
            "optional": "False",
            "description": "If bool, then determines whether to consider all features discrete or continuous. If array, then it should be either a boolean mask with shape (n_features,) or array with indices of discrete features. If ‘auto’, it is assigned to False for dense X and to True for sparse X.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "discrete_features"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use for MI estimation for continuous variables.",
            "scikit-learn": {
              "default_value": "3",
              "path": "n_neighbors"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "f classification",
      "other_names": ["analysis of variance f-value"],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.f_classif"
      },
      "type": "Scoring Function",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regressor_set",
            "kind_of_value": "{array-like, sparse matrix} shape = [n_samples, n_features]",
            "optional": "False",
            "description": "The set of regressors that will be tested sequentially.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "data_matrix",
            "kind_of_value": "array of shape(n_samples)",
            "optional": "False",
            "description": "The data matrix.",
            "scikit-learn": {
              "default_value": "",
              "path": "y"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "f regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.f_regression"
      },
      "type": "Scoring Function",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regressor_set",
            "kind_of_value": "{array-like, sparse matrix} shape = [n_samples, n_features]",
            "optional": "False",
            "description": "The set of regressors that will be tested sequentially.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "data_matrix",
            "kind_of_value": "array of shape(n_samples)",
            "optional": "False",
            "description": "The data matrix.",
            "scikit-learn": {
              "default_value": "",
              "path": "y"
            }
          },
          {
            "name": "center",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "If true, regressor_set and data_matrix will be centered.",
            "scikit-learn": {
              "default_value": "",
              "path": "center"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "chi2",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.chi2"
      },
      "type": "Scoring Function",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "sample_vectors",
            "kind_of_value": "{array-like, sparse matrix}, shape = (n_samples, n_features_in)",
            "optional": "False",
            "description": "Sample vectors.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "target_vector",
            "kind_of_value": "array-like, shape = (n_samples)",
            "optional": "False",
            "description": "Target vector (class labels).",
            "scikit-learn": {
              "default_value": "",
              "path": "y"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "univariate feature selector",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.GenericUnivariateSelect"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "scikit-learn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "mode",
            "kind_of_value": " {'percentile', 'k_best', 'fpr', 'fdr', 'fwe'}",
            "optional": "False",
            "description": "Feature selection mode.",
            "scikit-learn": {
              "default_value": "'percentile'",
              "path": "mode"
            }
          },
          {
            "name": "mode_parameter",
            "kind_of_value": "{float, integer}",
            "optional": "False",
            "description": "Parameter of the corresponding mode.",
            "scikit-learn": {
              "default_value": "0,00001",
              "path": "param"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select familiy-wise error rate",
      "other_names": ["select Fwe"],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.SelectFwe"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "scikit-learn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "max_uncorrected_p-value",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The highest uncorrected p-value for features to keep.",
            "scikit-learn": {
              "default_value": "0.05",
              "path": "alpha"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select estimated false discovery rate",
      "other_names": ["select Fdr"],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.SelectFdr"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "scikit-learn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "max_uncorrected_p-value",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The highest uncorrected p-value for features to keep.",
            "scikit-learn": {
              "default_value": "0.05",
              "path": "alpha"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select below false positive rate",
      "other_names": ["select Fpr"],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.SelectFpr"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "scikit-learn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "max_uncorrected_p-value",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The highest uncorrected p-value for features to keep.",
            "scikit-learn": {
              "default_value": "0.05",
              "path": "alpha"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select percentile",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.SelectPercentile"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "scikit-learn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "percentile",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Percent of features to keep.",
            "scikit-learn": {
              "default_value": "10",
              "path": "percentile"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select k best",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.SelectKBest"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "scikit-learn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "k",
            "kind_of_value": "{integer, 'all'}",
            "optional": "True",
            "description": "Number of top features to select.",
            "scikit-learn": {
              "default_value": "10",
              "path": "k"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "variance threshold",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.feature_selection.VarianceThreshold"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "threshold",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Features with a training-set variance lower than this threshold will be removed.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "threshold"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "label probagation",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.semi_supervised.LabelPropagation"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "kernel",
            "kind_of_value": "{'knn', 'rbf', a callable taking two inputs in shape (n_samples, n_features) and returns weight matrix in shape [n_samples, n_samples]}",
            "optional": "False",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "rbf_parameter",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Parameter for rbf kernel",
            "scikit-learn": {
              "default_value": "20",
              "path": "gamma"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer > 0",
            "optional": "True",
            "description": "Number of neighbors to use by for knn kernel.",
            "scikit-learn": {
              "default_value": "7",
              "path": "n_neighbors"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Convergence tolerance: threshold to consider the system at steady state",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "label spreading",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.semi_supervised.LabelSpreading"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "kernel",
            "kind_of_value": "{'knn', 'rbf', a callable taking two inputs in shape (n_samples, n_features) and returns weight matrix in shape [n_samples, n_samples]}",
            "optional": "False",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "rbf_parameter",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Parameter for rbf kernel",
            "scikit-learn": {
              "default_value": "20",
              "path": "gamma"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer > 0",
            "optional": "True",
            "description": "Number of neighbors to use by for knn kernel.",
            "scikit-learn": {
              "default_value": "7",
              "path": "n_neighbors"
            }
          },
          {
            "name": "calmping_factor",
            "kind_of_value": "float in [0,1]",
            "optional": "False",
            "description": "Clamping factor. A value in [0, 1] that specifies the relative amount that an instance should adopt the information from its neighbors as opposed to its initial label. 0 means  keeping the initial label information; 1 means replacing all initial information.",
            "scikit-learn": {
              "default_value": "0.2",
              "path": "alpha"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Convergence tolerance: threshold to consider the system at steady state",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "30",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "isotonic regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.isotonic.IsotonicRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "min_fit",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "If not None, set the lowest value of the fit to min_fit",
            "scikit-learn": {
              "default_value": "None",
              "path": "y_min"
            }
          },
          {
            "name": "max_fit",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "If not None, set the highest value of the fit to max_fit",
            "scikit-learn": {
              "default_value": "None",
              "path": "y_max"
            }
          },
          {
            "name": "increasing",
            "kind_of_value": "{'auto', boolean}",
            "optional": "True",
            "description": "If boolean, whether or not to fit the isotonic regression with outputs increasing or decreasing. The string value “auto” determines whether outputs should increase or decrease based on the Spearman correlation estimate’s sign.",
            "scikit-learn": {
              "default_value": "True",
              "path": "increasing"
            }
          },
          {
            "name": "out_of_bounds",
            "kind_of_value": "{'nan, 'clip', 'raise'}",
            "optional": "True",
            "description": "Defines how input-values outside the training domain should be handled. 'nan' set predictions to NaN, 'clip' set predicted values to the value corresponding to the nearest train interval endpoint. 'raise' allows to throw a ValueError.",
            "scikit-learn": {
              "default_value": "'nan'",
              "path": "out_of_bounds"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "probability calibration with cross validation",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.calibration.CalibratedClassifierCV"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "False",
            "description": "The classifier whose output decision function needs to be calibrated to offer more accurate prediction probability outputs. ",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "calibration_method",
            "kind_of_value": "{'sigmoid', 'isotonic'}",
            "optional": "False",
            "description": "The method to use for calibration.",
            "scikit-learn": {
              "default_value": "'sigmoid'",
              "path": "method"
            }
          },
          {
            "name": "cross-validation",
            "kind_of_value": "{integer, object (cross-validation generator),  iterable yielding train and test splits, None, 'prefit'",
            "optional": "True",
            "description": "Determines the cross-validation splitting strategy.",
            "scikit-learn": {
              "default_value": "3",
              "path": "cv"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "Brier score",
      "other_names": [],
      "implementation": {
        "scikit-learn": ""
      },
      "type": "Scoring Function",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "true_targets",
            "kind_of_value": "array, shape (n_samples)",
            "optional": "False",
            "description": "True targets.",
            "scikit-learn": {
              "default_value": "",
              "path": "y_true"
            }
          },
          {
            "name": "positive_probabilities",
            "kind_of_value": "array, shape (n_samples)",
            "optional": "False",
            "description": "Probabilities of the positive class.",
            "scikit-learn": {
              "default_value": "",
              "path": "y_prob"
            }
          },
          {
            "name": "sample_weight",
            "kind_of_value": "{array, shape (n_samples), None}",
            "optional": "True",
            "description": "Sample weights.",
            "scikit-learn": {
              "default_value": "None",
              "path": "sample_weight"
            }
          },
          {
            "name": "positive_label",
            "kind_of_value": "{integer, string}",
            "optional": "False",
            "description": "Label of the positive class. If None, the maximum label is used as positive class",
            "scikit-learn": {
              "default_value": "None",
              "path": "pos_label"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "multi-layer perceptron regressor",
      "other_names": ["MLP regressor"],
      "implementation": {
        "scikit-learn": "sklearn.neural_network.MLPRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "hidden_layer_sizes",
            "kind_of_value": "tuple, length = n_layers - 2",
            "optional": "False",
            "description": "The ith element represents the number of neurons in the ith hidden layer.",
            "scikit-learn": {
              "default_value": "(100,)",
              "path": "hidden_layer_sizes"
            }
          },
          {
            "name": "activation",
            "kind_of_value": " {'identity', 'logistic', 'tanh', 'relu'}",
            "optional": "False",
            "description": "Activation function for the hidden layer.",
            "scikit-learn": {
              "default_value": "'relu'",
              "path": "activation"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{'lbfgs', 'sgd', 'adam'}",
            "optional": "False",
            "description": "The solver for weight optimization.",
            "scikit-learn": {
              "default_value": "'adam'",
              "path": "solver"
            }
          },
          {
            "name": "l2_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "L2 penalty (regularization term) parameter.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "{integer, 'auto'}",
            "optional": "True",
            "description": "Size of minibatches for stochastic optimizers.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "batch_size"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{'constant', 'invscaling', 'adaptive'}",
            "optional": "False",
            "description": "Learning rate schedule for weight updates.",
            "scikit-learn": {
              "default_value": "'constant'",
              "path": "learning_rate"
            }
          },
          {
            "name": "learning_rate_init",
            "kind_of_value": "double",
            "optional": "True",
            "description": "The initial learning rate used. It controls the step-size in updating the weights.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "learning_rate_init"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "True",
            "description": "The exponent for inverse scaling learning rate.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "power_t"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to shuffle samples in each iteration.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "gradient_momentum",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Momentum for gradient descent update.",
            "scikit-learn": {
              "default_value": "0.9",
              "path": "momentum"
            }
          },
          {
            "name": "nesterovs_momentum",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use Nesterov’s momentum.",
            "scikit-learn": {
              "default_value": "True",
              "path": "nesterovs_momentum"
            }
          },
          {
            "name": "early_stopping",
            "kind_of_value": "boolean",
            "optional": "Flase",
            "description": "Whether to use early stopping to terminate training when validation score is not improving. If set to true, it will automatically set aside 10% of training data as validation and terminate training when validation score is not improving by at least tol for two consecutive epochs.",
            "scikit-learn": {
              "default_value": "Flase",
              "path": "early_stopping"
            }
          },
          {
            "name": "validation_fraction",
            "kind_of_value": "float between 0 and 1",
            "optional": "True",
            "description": "The proportion of training data to set aside as validation set for early stopping.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "validation_fraction"
            }
          },
          {
            "name": "adam_beta_1",
            "kind_of_value": "float should be in [0, 1)",
            "optional": "True",
            "description": "Exponential decay rate for estimates of first moment vector in adam.",
            "scikit-learn": {
              "default_value": "0.9",
              "path": "beta_1"
            }
          },
          {
            "name": "adam_beta_2",
            "kind_of_value": "float should be in [0, 1)",
            "optional": "True",
            "description": "Exponential decay rate for estimates of second moment vector in adam.",
            "scikit-learn": {
              "default_value": "0.999",
              "path": "beta_2"
            }
          },
          {
            "name": "adam_epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Value for numerical stability in adam.",
            "scikit-learn": {
              "default_value": "0.00000001",
              "path": "epsilon"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "200",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "multi-layer perceptron classifier",
      "other_names": ["MLP classifier"],
      "implementation": {
        "scikit-learn": "sklearn.neural_network.MLPClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "hidden_layer_sizes",
            "kind_of_value": "tuple, length = n_layers - 2",
            "optional": "False",
            "description": "The ith element represents the number of neurons in the ith hidden layer.",
            "scikit-learn": {
              "default_value": "(100,)",
              "path": "hidden_layer_sizes"
            }
          },
          {
            "name": "activation",
            "kind_of_value": " {'identity', 'logistic', 'tanh', 'relu'}",
            "optional": "False",
            "description": "Activation function for the hidden layer.",
            "scikit-learn": {
              "default_value": "'relu'",
              "path": "activation"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{'lbfgs', 'sgd', 'adam'}",
            "optional": "False",
            "description": "The solver for weight optimization.",
            "scikit-learn": {
              "default_value": "'adam'",
              "path": "solver"
            }
          },
          {
            "name": "l2_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "L2 penalty (regularization term) parameter.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "{integer, 'auto'}",
            "optional": "True",
            "description": "Size of minibatches for stochastic optimizers.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "batch_size"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{'constant', 'invscaling', 'adaptive'}",
            "optional": "False",
            "description": "Learning rate schedule for weight updates.",
            "scikit-learn": {
              "default_value": "'constant'",
              "path": "learning_rate"
            }
          },
          {
            "name": "learning_rate_init",
            "kind_of_value": "double",
            "optional": "True",
            "description": "The initial learning rate used. It controls the step-size in updating the weights.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "learning_rate_init"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "True",
            "description": "The exponent for inverse scaling learning rate.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "power_t"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to shuffle samples in each iteration.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "gradient_momentum",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Momentum for gradient descent update.",
            "scikit-learn": {
              "default_value": "0.9",
              "path": "momentum"
            }
          },
          {
            "name": "nesterovs_momentum",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use Nesterov’s momentum.",
            "scikit-learn": {
              "default_value": "True",
              "path": "nesterovs_momentum"
            }
          },
          {
            "name": "early_stopping",
            "kind_of_value": "boolean",
            "optional": "Flase",
            "description": "Whether to use early stopping to terminate training when validation score is not improving. If set to true, it will automatically set aside 10% of training data as validation and terminate training when validation score is not improving by at least tol for two consecutive epochs.",
            "scikit-learn": {
              "default_value": "Flase",
              "path": "early_stopping"
            }
          },
          {
            "name": "validation_fraction",
            "kind_of_value": "float between 0 and 1",
            "optional": "True",
            "description": "The proportion of training data to set aside as validation set for early stopping.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "validation_fraction"
            }
          },
          {
            "name": "adam_beta_1",
            "kind_of_value": "float should be in [0, 1)",
            "optional": "True",
            "description": "Exponential decay rate for estimates of first moment vector in adam.",
            "scikit-learn": {
              "default_value": "0.9",
              "path": "beta_1"
            }
          },
          {
            "name": "adam_beta_2",
            "kind_of_value": "float should be in [0, 1)",
            "optional": "True",
            "description": "Exponential decay rate for estimates of second moment vector in adam.",
            "scikit-learn": {
              "default_value": "0.999",
              "path": "beta_2"
            }
          },
          {
            "name": "adam_epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Value for numerical stability in adam.",
            "scikit-learn": {
              "default_value": "0.00000001",
              "path": "epsilon"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "200",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "Gaussian mixture",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.mixture.GaussianMixture"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of mixture components.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_components"
            }
          },
          {
            "name": "covariance_type",
            "kind_of_value": "{'full', 'tied', 'diag', 'spherical'}",
            "optional": "False",
            "description": "String describing the type of covariance parameters to use.",
            "scikit-learn": {
              "default_value": "'full'",
              "path": "covariance_type"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The convergence threshold.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "reg_covariance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Non-negative regularization added to the diagonal of covariance. Allows to assure that the covariance matrices are all positive.",
            "scikit-learn": {
              "default_value": "0.000001",
              "path": "reg_covar"
            }
          },
          {
            "name": "num_init",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of initializations to perform. The best results are kept.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_init"
            }
          },
          {
            "name": "init_params",
            "kind_of_value": "{'kmeans', 'random'}",
            "optional": "False",
            "description": "The method used to initialize the weights, the means and the precisions.",
            "scikit-learn": {
              "default_value": "'kmeans'",
              "path": "init_params"
            }
          },
          {
            "name": "weights_init",
            "kind_of_value": "{array-like, shape (n_components, ), None}",
            "optional": "True",
            "description": "The user-provided initial weights.",
            "scikit-learn": {
              "default_value": "None",
              "path": "weights_init"
            }
          },
          {
            "name": "means_init",
            "kind_of_value": "{array-like, shape (n_components,  n_features), None}",
            "optional": "True",
            "description": "The user-provided initial means.",
            "scikit-learn": {
              "default_value": "None",
              "path": "means_init"
            }
          },
          {
            "name": "precisions_init",
            "kind_of_value": "{array-like depending on 'covariance_type': (n_components,) if 'spherical', (n_features, n_features) if 'tied', (n_components, n_features) if 'diag',(n_components, n_features, n_features) if 'full', None}",
            "optional": "True",
            "description": "The user-provided initial precisions (inverse of the covariance matrices).",
            "scikit-learn": {
              "default_value": "None",
              "path": "precisions_init"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "",
      "other_names": [],
      "implementation": {
        "scikit-learn": ""
      },
      "type": "",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "",
            "kind_of_value": "",
            "optional": "",
            "description": "",
            "scikit-learn": {
              "default_value": "",
              "path": ""
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "",
            "kind_of_value": "",
            "optional": "",
            "description": "",
            "scikit-learn": {
              "default_value": "",
              "path": ""
            }
          }
        ],
        "execution_parameters": []
      }
    }
  ]
}