{
  "algorithms": [
    {
      "name": "linear regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.base.LinearRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": [
        ]
      }
    },
    {
      "name": "ridge regression",
      "other_names": [
        "Tikhonov regularization",
        "weight decay",
        "Tikhonov–Miller method",
        "Phillips–Twomey method",
        "constrained linear inversion",
        "linear regularization"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.ridge.Ridge"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularisation_strength",
            "kind_of_value": "float, array-like in the shape of the targets",
            "optional": "False",
            "description": "Regularization strength; must be a positive float. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization. Lambda corresponds to C^-1 in other linear models such as LogisticRegression or LinearSVC.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{‘auto’, ‘svd’, ‘cholesky’, ‘lsqr’, ‘sparse_cg’, ‘sag’, ‘saga’}",
            "optional": "False",
            "description": "Solver to use in the computational routines: -‘auto’ chooses the solver automatically based on the type of data. -‘svd’ uses a Singular Value Decomposition of X to compute the Ridge coefficients. More stable for singular matrices than ‘cholesky’. -‘cholesky’ uses the standard scipy.linalg.solve function to obtain a closed-form solution. -‘sparse_cg’ uses the conjugate gradient solver as found in scipy.sparse.linalg.cg. As an iterative algorithm, this solver is more appropriate than ‘cholesky’ for large-scale data (possibility to set tol and max_iter). -‘lsqr’ uses the dedicated regularized least-squares routine scipy.sparse.linalg.lsqr. It is the fastest but may not be available in old scipy versions. It also uses an iterative procedure. -‘sag’ uses a Stochastic Average Gradient descent, and ‘saga’ uses its improved, unbiased version named SAGA. Both methods also use an iterative procedure, and are often faster than other solvers when both n_samples and n_features are large. Note that ‘sag’ and ‘saga’ fast convergence is only guaranteed on features with approximately the same scale. You can preprocess the data with a scaler from sklearn.preprocessing.",
            "scikit-learn": {
              "default_value": "auto",
              "path": "solver"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": [
        ]
      }
    },
    {
      "name": "lasso",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.Lasso"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1 term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tolerance, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "positive",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "scikit-learn": {
              "default_value": "False",
              "path": "positive"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "string",
            "optional": "False",
            "description": "If set to ‘random’, a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to ‘random’) often leads to significantly faster convergence especially when tol is higher than 1e-4.",
            "scikit-learn": {
              "default_value": "cyclic",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "multi-task lasso",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.MultiTaskLasso"
      },
      "type": "Regression",
      "hyper_parameters": [
        {
          "name": "lambda",
          "kind_of_value": "float",
          "optional": "True",
          "description": "Constant that multiplies the L1/L2 term.",
          "scikit-learn": {
            "default_value": "1.0",
            "path": "alpha"
          }
        },
        {
          "name": "intercept",
          "kind_of_value": "boolean",
          "optional": "False",
          "description": "Whether to calculate the intercept for this model.",
          "scikit-learn": {
            "default_value": "True",
            "path": "fit_intercept"
          }
        },
        {
          "name": "normalize",
          "kind_of_value": "boolean",
          "optional": "True",
          "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
          "scikit-learn": {
            "default_value": "False",
            "path": "normalize"
          }
        },
        {
          "name": "tolerance",
          "kind_of_value": "float",
          "optional": "True",
          "description": "The tolerance for the optimization: if the updates are smaller than tol, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
          "scikit-learn": {
            "default_value": "0.0001",
            "path": "tol"
          }
        },
        {
          "name": "reuse_previous",
          "kind_of_value": "boolean",
          "optional": "True",
          "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
          "scikit-learn": {
            "default_value": "False",
            "path": "warm_start"
          }
        },
        {
          "name": "selection",
          "kind_of_value": "string",
          "optional": "False",
          "description": "If set to ‘random’, a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to ‘random’) often leads to significantly faster convergence especially when tol is higher than 1e-4.",
          "scikit-learn": {
            "default_value": "cyclic",
            "path": "selection"
          }
        }
      ],
      "optimisation_parameters": [
        {
          "name": "max_iterations",
          "kind_of_value": "integer",
          "optional": "True",
          "description": "Maximum number of iterations.",
          "scikit-learn": {
            "default_value": "None",
            "path": "max_iter"
          }
        }
      ],
      "execution_parameters": [
      ]
    },
    {
      "name": "elastic net",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.ElasticNet"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_l2_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1/L2 term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The ElasticNet mixing parameter, with 0 <= l1_ratio <= 1. For l1_ratio = 0 the penalty is an L2 penalty. For l1_ratio = 1 it is an L1 penalty. For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "l1_ratio"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tol, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "positive",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "scikit-learn": {
              "default_value": "False",
              "path": "positive"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "string",
            "optional": "False",
            "description": "If set to ‘random’, a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to ‘random’) often leads to significantly faster convergence especially when tol is higher than 1e-4.",
            "scikit-learn": {
              "default_value": "cyclic",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "boolean, array-like",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "scikit-learn": {
              "default_value": "False",
              "path": "precompute"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": [
        ]
      }
    },
    {
      "name": "multi-task elastic net",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.MultiTaskElasticNet"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_l2_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1/L2 term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The ElasticNet mixing parameter, with 0 <= l1_ratio <= 1. For l1_ratio = 0 the penalty is an L2 penalty. For l1_ratio = 1 it is an L1 penalty. For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "l1_ratio"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tol, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "string",
            "optional": "False",
            "description": "If set to ‘random’, a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to ‘random’) often leads to significantly faster convergence especially when tol is higher than 1e-4.",
            "scikit-learn": {
              "default_value": "cyclic",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": [
        ]
      }
    },
    {
      "name": "least angle regression",
      "other_names": [
        "LARS"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.Lars"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "nonzero_coefficients",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Target number of non-zero coefficients.",
            "scikit-learn": {
              "default_value": "500",
              "path": "n_nonzero_coefs"
            }
          },
          {
            "name": "eps",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems.",
            "scikit-learn": {
              "default_value": "2.2204460492503131e-16",
              "path": "eps"
            }
          },
          {
            "name": "positive",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "scikit-learn": {
              "default_value": "False",
              "path": "positive"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "boolean, array-like",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "scikit-learn": {
              "default_value": "False",
              "path": "precompute"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "lasso least angle regression",
      "other_names": [
        "LassoLars"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.LassoLars"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "penalty_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the penalty term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "eps",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems.",
            "scikit-learn": {
              "default_value": "2.2204460492503131e-16",
              "path": "eps"
            }
          },
          {
            "name": "positive",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "scikit-learn": {
              "default_value": "False",
              "path": "positive"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{True, False, ‘auto’}",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "scikit-learn": {
              "default_value": "auto",
              "path": "precompute"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "orthogonal matching pursuit model",
      "other_names": [
        "OMP"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.OrthogonalMatchingPursuit"
      },
      "type": "Model Fit Aproximator",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "nonzero_coefficients",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Target number of non-zero coefficients.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_nonzero_coefs"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Maximum norm of the residual.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "True",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{True, False, ‘auto’}",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix  and Xy matrix to speed up calculations. Matrices can also be directly passed to the fit method.",
            "scikit-learn": {
              "default_value": "auto",
              "path": "precompute"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "n-target orthogonal matching pursuit",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.orthogonal_mp"
      },
      "type": "Model Fit Aproximator",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "input_data",
            "kind_of_value": "array, shape (n_samples, n_features)",
            "optional": "False",
            "description": "Input data. Columns are assumed to have unit norm.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "input_targets",
            "kind_of_value": "array, shape (n_samples) or (n_samples, n_targets)",
            "optional": "False",
            "description": "Input targets",
            "scikit-learn": {
              "default_value": "",
              "path": "Y"
            }
          },
          {
            "name": "nonzero_coefficients",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Target number of non-zero coefficients.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_nonzero_coefs"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Maximum norm of the residual.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{True, False, ‘auto’}",
            "optional": "False",
            "description": "Whether to perform precomputations.",
            "scikit-learn": {
              "default_value": "auto",
              "path": "precompute"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "bayesian ridge regression",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.BayesianRidge"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "alpha_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the alpha parameter.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "alpha_1"
            }
          },
          {
            "name": "alpha_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the alpha parameter.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "alpha_2"
            }
          },
          {
            "name": "lambda_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the lambda parameter.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "lambda_1"
            }
          },
          {
            "name": "lambda_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the lambda parameter.",
            "scikit-learn": {
              "default_value": "0.000006",
              "path": "lambda_2"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "300",
              "path": "n_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "automatic relevance determination regression",
      "other_names": [
        "ARD regrssion"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.ARDRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "alpha_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the alpha parameter.",
            "scikit-learn": {
              "default_value": "1e-06",
              "path": "alpha_1"
            }
          },
          {
            "name": "alpha_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the alpha parameter.",
            "scikit-learn": {
              "default_value": "1e-06",
              "path": "alpha_2"
            }
          },
          {
            "name": "lambda_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the lambda parameter.",
            "scikit-learn": {
              "default_value": "1e-06",
              "path": "lambda_1"
            }
          },
          {
            "name": "lambda_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the lambda parameter.",
            "scikit-learn": {
              "default_value": "1e-06",
              "path": "lambda_2"
            }
          },
          {
            "name": "threshold_lambda",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold for removing (pruning) weights with high precision from the computation. ",
            "scikit-learn": {
              "default_value": "10000.0",
              "path": "threshold_lambda"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "scikit-learn": {
              "default_value": "False",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "300",
              "path": "n_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "logistic regression",
      "other_names": [
        "logit regression",
        "maximum-entropy classification",
        "MaxEnt",
        "log-linear classifier"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.LogisticRegression"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "penalty",
            "kind_of_value": "{l1, l2}",
            "optional": "False",
            "description": "Used to specify the norm used in the penalization.",
            "scikit-learn": {
              "default_value": "l2",
              "path": "penalty"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Tolerance for stopping criteria.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "inverse_regularisation_strength",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Specifies if a constant (a.k.a. bias or intercept) should be added to the decision function.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "dict or ‘balanced’",
            "optional": "False",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{‘newton-cg’, ‘lbfgs’, ‘liblinear’, ‘sag’, ‘saga’}",
            "optional": "False",
            "description": "Solver to use in the computational routines.",
            "scikit-learn": {
              "default_value": "liblinear",
              "path": "solver"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of CPU cores used when parallelizing over classes.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "stochastic gradient descent classifier",
      "other_names": [
        "SGD classifier"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.SGDClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss_function",
            "kind_of_value": "{‘hinge’, ‘log’, ‘modified_huber’, ‘squared_hinge’, ‘perceptron’, ‘squared_loss’, ‘huber’, ‘epsilon_insensitive’, ‘squared_epsilon_insensitive’}",
            "optional": "False",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'hinge'",
              "path": "loss"
            }
          },
          {
            "name": "regularization_term",
            "kind_of_value": "{'none', 'l2', 'l1', 'elasticnet'}",
            "optional": "False",
            "description": "The penalty (aka regularization term) to be used.",
            "scikit-learn": {
              "default_value": "l2",
              "path": "penalty"
            }
          },
          {
            "name": "regualrisation_multiplier",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Constant that multiplies the regularization term.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The Elastic Net mixing parameter.",
            "scikit-learn": {
              "default_value": "0.15",
              "path": "l1_ratio"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{constant, optimal, invscaling}",
            "optional": "True",
            "description": "where t0 is chosen by a heuristic proposed by Leon Bottou.",
            "scikit-learn": {
              "default_value": "optimal",
              "path": "learning_rate"
            }
          },
          {
            "name": "eta0",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The initial learning rate for the ‘constant’ or ‘invscaling’ schedules.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "eta0"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The exponent for inverse scaling learning rate.",
            "scikit-learn": {
              "default_value": "0.5",
              "path": " power_t"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{{class_label: weight}, balanced,  None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of CPUs to use to do the OVA (One Versus All, for multi-class problems) computation. -1 means ‘all CPUs’.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "stochastic gradient descent regressor",
      "other_names": [
        "SGD regressor"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.SGDRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss_function",
            "kind_of_value": "{ ‘squared_loss’, ‘huber’, ‘epsilon_insensitive’, ‘squared_epsilon_insensitive’}",
            "optional": "False",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "'squared_loss'",
              "path": "loss"
            }
          },
          {
            "name": "regularization_term",
            "kind_of_value": "{'none', 'l2', 'l1', 'elasticnet'}",
            "optional": "False",
            "description": "The penalty (aka regularization term) to be used.",
            "scikit-learn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "regualrisation_multiplier",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Constant that multiplies the regularization term.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The Elastic Net mixing parameter.",
            "scikit-learn": {
              "default_value": "0.15",
              "path": "l1_ratio"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{'constant', 'optimal', 'invscaling'}",
            "optional": "True",
            "description": "where t0 is chosen by a heuristic proposed by Leon Bottou.",
            "scikit-learn": {
              "default_value": "'invscaling'",
              "path": "learning_rate"
            }
          },
          {
            "name": "eta0",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The initial learning rate for the ‘constant’ or ‘invscaling’ schedules.",
            "scikit-learn": {
              "default_value": "0.01",
              "path": "eta0"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The exponent for inverse scaling learning rate.",
            "scikit-learn": {
              "default_value": "0.25",
              "path": " power_t"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "perceptron",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.Perceptron"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularization_term",
            "kind_of_value": "{none, l2, l1, elasticnet}",
            "optional": "False",
            "description": "The penalty (aka regularization term) to be used.",
            "scikit-learn": {
              "default_value": "None",
              "path": "penalty"
            }
          },
          {
            "name": "regularisation_multiplier",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Constant that multiplies the regularization term.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "eta0",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The initial learning rate for the ‘constant’ or ‘invscaling’ schedules.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "eta0"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{{class_label: weight}, balanced,  None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          },
          {
            "name": "epochs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of passes over the training data (aka epochs).",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_iter"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "passive aggressive classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.PassiveAggressiveClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regualrisation",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Maximum step size (regularization).",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{hinge, squared_hinge}",
            "optional": "True",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "hinge",
              "path": "loss"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "dict or ‘balanced’ or None",
            "optional": "True",
            "description": "Weights associated with classes.",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "epochs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of passes over the training data (aka epochs).",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of of CPUs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "passive aggressive regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.PassiveAggressiveRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regualrisation",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Maximum step size (regularization).",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{epsilon_insensitive, squared_epsilon_insensitive}",
            "optional": "True",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "epsilon_insensitive",
              "path": "loss"
            }
          },
          {
            "name": "update_threshold",
            "kind_of_value": "float",
            "optional": "False",
            "description": "If the difference between the current prediction and the correct label is below this threshold, the model is not updated.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "epsilon"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "epochs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of passes over the training data (aka epochs).",
            "scikit-learn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "random sample consensus regressor",
      "other_names": [
        "RANSAC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.RANSACRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "object",
            "optional": "True",
            "description": "base_estimator.",
            "scikit-learn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "min_samples",
            "kind_of_value": "int (>= 1) or float ([0, 1])",
            "optional": "True",
            "description": "Minimum number of samples chosen randomly from original data.",
            "scikit-learn": {
              "default_value": "None",
              "path": "min_samples"
            }
          },
          {
            "name": "residual_threshold",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Maximum residual for a data sample to be classified as an inlier. By default the threshold is chosen as the MAD (median absolute deviation) of the target values y.",
            "scikit-learn": {
              "default_value": "None",
              "path": "residual_threshold"
            }
          },
          {
            "name": "loss",
            "kind_of_value": "{absolute_loss, squared_loss}",
            "optional": "True",
            "description": "If loss is a callable, then it should be a function that takes two arrays as inputs, the true and predicted value and returns a 1-D array with the i-th value of the array corresponding to the loss on X[i].",
            "scikit-learn": {
              "default_value": "absolute_loss",
              "path": "loss"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "iterations_random_sampling",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations for random sample selection.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_trials"
            }
          },
          {
            "name": "max_skips",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations that can be skipped due to finding zero inliers or invalid data.",
            "scikit-learn": {
              "default_value": "inf",
              "path": "max_skips"
            }
          },
          {
            "name": "stop_n_inliers",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Stop iteration if at least this number of inliers are found.",
            "scikit-learn": {
              "default_value": "inf",
              "path": "stop_n_inliers"
            }
          },
          {
            "name": "stop_score",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Stop iteration if score is greater equal than this threshold.",
            "scikit-learn": {
              "default_value": "inf",
              "path": "stop_score"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "theil-sen estimator",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.TheilSenRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "max_subpopulation",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "",
            "scikit-learn": {
              "default_value": "10000",
              "path": "max_subpopulation"
            }
          },
          {
            "name": "n_subsamples",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of samples to calculate the parameters.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_subsamples"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance when calculating spatial median.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations for the calculation of spatial median.",
            "scikit-learn": {
              "default_value": "300",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of CPUs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "huber regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.linear_model.HuberRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "number_of_outliers",
            "kind_of_value": "float > 1.0",
            "optional": "False",
            "description": "The parameter controls the number of samples that should be classified as outliers. The smaller the parameter, the more robust it is to outliers.",
            "scikit-learn": {
              "default_value": "1.35",
              "path": "epsilon"
            }
          },
          {
            "name": "regularization_parameter",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Regularization parameter.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "scikit-learn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "scikit-learn": {
              "default_value": "1e-05",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations that scipy.optimize.fmin_l_bfgs_b should run for.",
            "scikit-learn": {
              "default_value": "100",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "linear discriminant analysis",
      "other_names": [
        "LDA"
      ],
      "implementation": {
        "scikit-learn": "sklearn.discriminant_analysis.LinearDiscriminantAnalysis"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimation_algorithm",
            "kind_of_value": "{svd, lsqr, eigen}",
            "optional": "True",
            "description": "Possible values: singular value decomposition (svd), least squares solution (lsqr), eigenvalue decomposition (eigen)",
            "scikit-learn": {
              "default_value": "svd",
              "path": "solver"
            }
          },
          {
            "name": "shrinkage",
            "kind_of_value": "{None, auto, float between 0 and 1}",
            "optional": "True",
            "description": "Shrinkage is a tool to improve estimation of covariance matrices in situations where the number of training samples is small compared to the number of features. Possible values: no shrinkage (None), automatic shrinkage using the Ledoit-Wolf lemma (auto), fixed shrinkage parameter(float between 0 and 1)",
            "scikit-learn": {
              "default_value": "None",
              "path": "shrinkage"
            }
          },
          {
            "name": "n_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of components (< n_classes - 1) for dimensionality reduction.",
            "scikit-learn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold used for rank estimation in SVD solver.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "quadratic discriminant analysis",
      "other_names": [
        "QDA"
      ],
      "implementation": {
        "scikit-learn": "sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularisation_parameter",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Regularizes the covariance estimate.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "reg_param"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold used for rank estimation.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "kernel ridge regression",
      "other_names": [
        "KRR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.kernel_ridge.KernelRidge"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularisation_strength",
            "kind_of_value": "float, array-like in the shape of the targets",
            "optional": "False",
            "description": "Regularization strength; must be a positive float. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization. Lambda corresponds to C^-1 in other linear models such as LogisticRegression or LinearSVC.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{string, callable}",
            "optional": "False",
            "description": "Kernel mapping used internally. A callable should accept two arguments and the keyword arguments passed to this object as kernel_params, and should return a floating point number.",
            "scikit-learn": {
              "default_value": "linear",
              "path": "kernel"
            }
          },
          {
            "name": "gamma",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Gamma parameter for the RBF, laplacian, polynomial, exponential chi2 and sigmoid kernels. Interpretation depends on kernels.",
            "scikit-learn": {
              "default_value": "None",
              "path": "gamma"
            }
          },
          {
            "name": "kernel_degree",
            "kind_of_value": "float",
            "optional": "float",
            "description": "Degree of the polynomial kernel.",
            "scikit-learn": {
              "default_value": "3.0",
              "path": "degree"
            }
          },
          {
            "name": "zero_coefficient",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Zero coefficient for polynomial and sigmoid kernels.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "coef0"
            }
          },
          {
            "name": "kernel_parameters",
            "kind_of_value": "mapping of string to any",
            "optional": "True",
            "description": "Additional parameters (keyword arguments) for kernel function passed as callable object.",
            "scikit-learn": {
              "default_value": "None",
              "path": "kernel_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "c-support vector classification.",
      "other_names": [
        "SVC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.SVC"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function (‘poly’). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float or 'auto'",
            "optional": "True",
            "description": "Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’. If kernel_coefficient is ‘auto’ then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dictionary with weights for all calsses, 'balanced', None}",
            "optional": "True",
            "description": "Weights the classes. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "nu-support vector classification",
      "other_names": [
        "nuSVC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.NuSVC"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "nu",
            "kind_of_value": "float (0, 1]",
            "optional": "True",
            "description": "An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1].",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "nu"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function (‘poly’). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float or 'auto'",
            "optional": "True",
            "description": "Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’. If kernel_coefficient is ‘auto’ then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dictionary with weights for all calsses, 'balanced', None}",
            "optional": "True",
            "description": "Weights the classes. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "linear-support vector classification",
      "other_names": [
        "linear SVC"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.LinearSVC"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "penalty",
            "kind_of_value": "{'l1', 'l2'}",
            "optional": "False",
            "description": "Specifies the norm used in the penalization.",
            "scikit-learn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'hinge', ‘squared_hinge’}",
            "optional": "False",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "‘squared_hinge’",
              "path": "loss"
            }
          },
          {
            "name": "dual",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Select the algorithm to either solve the dual or primal optimization problem.",
            "scikit-learn": {
              "default_value": "True",
              "path": "dual"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criteria.",
            "scikit-learn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "multi_class_strategy",
            "kind_of_value": "{'ovr', 'crammer_singer'}",
            "optional": "False",
            "description": "Determines the multi-class strategy if y contains more than two classes.",
            "scikit-learn": {
              "default_value": "'ovr'",
              "path": "multi_class"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dictionary with weights for all calsses, 'balanced', None}",
            "optional": "True",
            "description": "Weights the classes. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
            "scikit-learn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations to be run.",
            "scikit-learn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "epsilon-support vector regression",
      "other_names": [
        "SVR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.SVR"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Epsilon in the epsilon-SVR model. It specifies the epsilon-tube within which no penalty is associated in the training loss function with points predicted within a distance epsilon from the actual value.",
            "scikit-learn": {
              "default_value": "0.1",
              "path": "epsilon"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function (‘poly’). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float or 'auto'",
            "optional": "True",
            "description": "Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’. If kernel_coefficient is ‘auto’ then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "nu-support vector regression",
      "other_names": [
        "nuSVR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.NuSVR"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "nu",
            "kind_of_value": "float (0, 1]",
            "optional": "True",
            "description": "An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1].",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "nu"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function (‘poly’). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float or 'auto'",
            "optional": "True",
            "description": "Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’. If kernel_coefficient is ‘auto’ then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "linear-support vector regression",
      "other_names": [
        "linearSVR"
      ],
      "implementation": {
        "scikit-learn": "sklearn.svm.LinearSVR"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "scikit-learn": {
              "default_value": "’epsilon_insensitive’",
              "path": "loss"
            }
          },
          {
            "name": "epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Epsilon parameter in the epsilon-insensitive loss function. Note that the value of this parameter depends on the scale of the target variable y.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "epsilon"
            }
          },
          {
            "name": "dual",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Select the algorithm to either solve the dual or primal optimization problem.",
            "scikit-learn": {
              "default_value": "True",
              "path": "dual"
            }
          },
          {
            "name": "intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "scikit-learn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations to be run.",
            "scikit-learn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "one-class support vector machine",
      "other_names": ["one-calss SVM"],
      "implementation": {
        "scikit-learn": "sklearn.svm.OneClassSVM"
      },
      "type": "Outlier Detection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "nu",
            "kind_of_value": "float (0, 1]",
            "optional": "True",
            "description": "An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1].",
            "scikit-learn": {
              "default_value": "0.5",
              "path": "nu"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "scikit-learn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function (‘poly’). ",
            "scikit-learn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float or 'auto'",
            "optional": "True",
            "description": "Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’. If kernel_coefficient is ‘auto’ then 1/n_features will be used instead.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.",
            "scikit-learn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "scikit-learn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "scikit-learn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "scikit-learn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "scikit-learn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "nearest neighbours",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.NearestNeighbors"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use by default for kneighbors queries.",
            "scikit-learn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "radius",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Range of parameter space to use by default for radius_neighbors queries.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "radius"
            }
          },
          {
            "name": "algorithm",
            "kind_of_value": "{‘ball_tree’, ‘kd_tree’, ‘brute’, ‘auto’}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{‘cityblock’, ‘cosine’, ‘euclidean’, ‘l1’, ‘l2’, ‘manhattan’, ‘braycurtis’, ‘canberra’, ‘chebyshev’, ‘correlation’, ‘dice’, ‘hamming’, ‘jaccard’, ‘kulsinski’, ‘mahalanobis’, ‘matching’, ‘minkowski’, ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’, ‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘yule’, a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "Metric to use for distance computation.",
            "scikit-learn": {
              "default_value": "’minkowski’",
              "path": "metric"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "k-d tree",
      "other_names": ["KDTree", "k-dimensional tree"],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.KDTree"
      },
      "type": "Search Tree",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "samples_feature",
            "kind_of_value": "array, shape: [n_samples, n_features]",
            "optional": "False",
            "description": "n_samples is the number of points in the data set, and n_features is the dimension of the parameter space.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'p', 'l1', 'chebyshev', 'manhattan', 'minkowski', 'cityblock', 'l2', 'euclidean', 'infinity'}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "’minkowski’",
              "path": "metric"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "leaf_size",
            "kind_of_value": "positive integer",
            "optional": "False",
            "description": "Number of points at which to switch to brute-force. Changing leaf_size will not affect the results of a query, but can significantly impact the speed of a query and the memory required to store the constructed tree.",
            "scikit-learn": {
              "default_value": "40",
              "path": "leaf_size"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "ball tree",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.BallTree"
      },
      "type": "Search Tree",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "samples_feature",
            "kind_of_value": "array, shape: [n_samples, n_features]",
            "optional": "False",
            "description": "n_samples is the number of points in the data set, and n_features is the dimension of the parameter space.",
            "scikit-learn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'seuclidean', 'hamming', 'dice', 'jaccard', 'matching', 'russellrao',  'euclidean', 'kulsinski', 'wminkowski', 'chebyshev', 'mahalanobis', 'sokalmichener', 'rogerstanimoto', 'infinity', 'p', 'canberra',  'haversine', 'sokalsneath', 'l1', 'minkowski', 'pyfunc', 'l2', 'cityblock', 'braycurtis', 'manhattan'}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "’minkowski’",
              "path": "metric"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "leaf_size",
            "kind_of_value": "positive integer",
            "optional": "False",
            "description": "Number of points at which to switch to brute-force. Changing leaf_size will not affect the results of a query, but can significantly impact the speed of a query and the memory required to store the constructed tree.",
            "scikit-learn": {
              "default_value": "40",
              "path": "leaf_size"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "radius neighbors classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.RadiusNeighborsClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "radius",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Range of parameter space to use.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "radius"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{‘uniform’, ‘distance’, callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "scikit-learn": {
              "default_value": "‘uniform’",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{‘cityblock’, ‘cosine’, ‘euclidean’, ‘l1’, ‘l2’, ‘manhattan’, ‘braycurtis’, ‘canberra’, ‘chebyshev’, ‘correlation’, ‘dice’, ‘hamming’, ‘jaccard’, ‘kulsinski’, ‘mahalanobis’, ‘matching’, ‘minkowski’, ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’, ‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘yule’, a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "’minkowski’",
              "path": "metric"
            }
          },
          {
            "name": "outlier_label",
            "kind_of_value": "integer or 'None'",
            "optional": "True",
            "description": "Label, which is given for outlier samples (samples with no neighbors on given radius). If set to None, ValueError is raised, when outlier is detected.",
            "scikit-learn": {
              "default_value": "None",
              "path": "outlier_label"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "k-nn classifier",
      "other_names": [" k-nearest neighbors calssifier"],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.KNeighborsClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_neighbors",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use.",
            "scikit-learn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{‘uniform’, ‘distance’, callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "scikit-learn": {
              "default_value": "‘uniform’",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{‘cityblock’, ‘cosine’, ‘euclidean’, ‘l1’, ‘l2’, ‘manhattan’, ‘braycurtis’, ‘canberra’, ‘chebyshev’, ‘correlation’, ‘dice’, ‘hamming’, ‘jaccard’, ‘kulsinski’, ‘mahalanobis’, ‘matching’, ‘minkowski’, ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’, ‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘yule’, a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "’minkowski’",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "k-nn regressor",
      "other_names": [" k-nearest neighbors regressor"],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.KNeighborsRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_neighbors",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use.",
            "scikit-learn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{‘uniform’, ‘distance’, callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "scikit-learn": {
              "default_value": "‘uniform’",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{‘cityblock’, ‘cosine’, ‘euclidean’, ‘l1’, ‘l2’, ‘manhattan’, ‘braycurtis’, ‘canberra’, ‘chebyshev’, ‘correlation’, ‘dice’, ‘hamming’, ‘jaccard’, ‘kulsinski’, ‘mahalanobis’, ‘matching’, ‘minkowski’, ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’, ‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘yule’, a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "’minkowski’",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "scikit-learn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "radius neighbors regressor",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.RadiusNeighborsRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "radius",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Range of parameter space to use.",
            "scikit-learn": {
              "default_value": "1.0",
              "path": "radius"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{‘uniform’, ‘distance’, callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "scikit-learn": {
              "default_value": "‘uniform’",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "scikit-learn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "scikit-learn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "scikit-learn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{‘cityblock’, ‘cosine’, ‘euclidean’, ‘l1’, ‘l2’, ‘manhattan’, ‘braycurtis’, ‘canberra’, ‘chebyshev’, ‘correlation’, ‘dice’, ‘hamming’, ‘jaccard’, ‘kulsinski’, ‘mahalanobis’, ‘matching’, ‘minkowski’, ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’, ‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘yule’, a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "scikit-learn": {
              "default_value": "’minkowski’",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "scikit-learn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "nearest centroid classifier",
      "other_names": [],
      "implementation": {
        "scikit-learn": "sklearn.neighbors.NearestCentroid"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "distance_metric",
            "kind_of_value": "{[‘cityblock’, ‘cosine’, ‘euclidean’, ‘l1’, ‘l2’, ‘manhattan’, ‘braycurtis’, ‘canberra’, ‘chebyshev’, ‘correlation’, ‘dice’, ‘hamming’, ‘jaccard’, ‘kulsinski’, ‘mahalanobis’, ‘matching’, ‘minkowski’, ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’, ‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘yule’}",
            "optional": "False",
            "description": "The metric to use when calculating distance between instances in a feature array.",
            "scikit-learn": {
              "default_value": "'euclidean'’",
              "path": "metric"
            }
          },
          {
            "name": "shrink_threshold",
            "kind_of_value": "float or None",
            "optional": "True",
            "description": "Threshold for shrinking centroids to remove features.",
            "scikit-learn": {
              "default_value": "None",
              "path": "shrink_threshold"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "",
      "other_names": [],
      "implementation": {
        "scikit-learn": ""
      },
      "type": "",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "",
            "kind_of_value": "",
            "optional": "",
            "description": "",
            "scikit-learn": {
              "default_value": "",
              "path": ""
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "",
            "kind_of_value": "",
            "optional": "",
            "description": "",
            "scikit-learn": {
              "default_value": "",
              "path": ""
            }
          }
        ],
        "execution_parameters": []
      }
    }
  ]
}